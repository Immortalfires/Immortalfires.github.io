<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring框架常见总结</title>
      <link href="/2022/03/25/220325/"/>
      <url>/2022/03/25/220325/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring是一个轻量级的Java开发框架，目的在于提高开发效率。主要由以下几个模块组成</p><ul><li>Spring Core：核心类库，提供IOC依赖注入</li><li>Spring AOP：提供了面向切面的编程实现</li><li>Spring Context：提供框架式的Bean访问方法</li><li>Spring DAO：对JDBC的抽象，简化了数据异常的处理</li><li>Spring ORM：对现有ORM框架的的支持</li><li>Spring Web：支持与struts继承，提供基本面向web的综合特性</li><li>Spring MVC：面向应用的Model-View-Controller实现</li></ul><h2 id="IOC（控制反转）"><a href="#IOC（控制反转）" class="headerlink" title="IOC（控制反转）"></a>IOC（控制反转）</h2><p>​    IOC是一种设计思想，将原本在程序中手动创建对象的控制权，交给Spring框架管理，由Ioc容器根据配置文件去创建实力和管理实例。仅仅只需要配置好配置文件或注解，无需考虑对象被如何创建。</p><p>​    它降低了对象之间的耦合，使得资源变得容易管理。</p><p>​    实现方式：DI（对象注入）</p><h2 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h2><p>​    作为对面向对象的补充，将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑（例如事务处理、日志管理、权限控制等），抽取并封装成可重用模块（切面），降低模块耦合，提高可维护性。</p><p>​    AOP主要通过代理实现，JDK Proxy或者Cglib（动态代理）AspectJ（静态代理）</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p>代指被Ioc容器所管理的对象</p><p>作用域：</p><ul><li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常见知识点</title>
      <link href="/2022/03/25/220324-1/"/>
      <url>/2022/03/25/220324-1/</url>
      
        <content type="html"><![CDATA[<p>OSI七层模型：应用层，表示层，会话层，运输层、网络层、数据链路层、物理层；一般学习的是五层协议体系结构，应用层、运输层、网络层、数据链路层、物理层。</p><h1 id="一、应用层"><a href="#一、应用层" class="headerlink" title="一、应用层"></a>一、应用层</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本协议，默认端口80，基于TCP协议，发送http请求前要先建立TCP连接（3次握手），是个[无状态](#HTTP 是不保存状态的协议, 如何保存用户状态?)协议，一般使用session来记录客户端用户的状态。</p><p>优点：扩展性强，速度快，可跨平台</p><p>缺点：明文，不安全，不维护客户端状态</p><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><table><thead><tr><th></th><th>含义</th><th>常见码</th></tr></thead><tbody><tr><td>1xx</td><td>表示目前为协议处理中间状态</td><td></td></tr><tr><td>2xx</td><td>成功，报文已收到并被处理</td><td>200</td></tr><tr><td>3xx</td><td>重定向，资源位置改变，需要客户端重新发送请求</td><td></td></tr><tr><td>4xx</td><td>客户端错误，报文有误</td><td>404</td></tr><tr><td>5xx</td><td>服务器错误</td><td>500</td></tr></tbody></table><p>GET是用于获取数据的，POST用于提交数据</p><table><thead><tr><th>状态码</th><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功，用于POST、GET</td></tr><tr><td>201</td><td>Created</td><td>请求成功并创建新的资源</td></tr><tr><td>202</td><td>Accpeted</td><td>已接受请求但未处理完成</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动，移至新URI</td></tr><tr><td>302</td><td>Found</td><td>临时移动，应使用原URI</td></tr><tr><td>404</td><td>Not Found</td><td>无法根据客户端请求找到资源</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="HTTPS与HTTP"><a href="#HTTPS与HTTP" class="headerlink" title="HTTPS与HTTP"></a>HTTPS与HTTP</h3><p>HTTPS是HTTP的加强安全版本，额外使用SSL/TLS作为加密和安全认证，默认端口号未443。相较HHTP保密性好，信任度高，耗费了更多服务器资源。</p><p>SSL/TLS实际消息使用对称加密（通信双方使用唯一密钥），使用非对称加密对密钥进行加密，保证传输消息的保密性（克服HTTP的不安全性）。还需要向CA申请数字证书，保证服务器身份可信（克服HTTP的冒充风险）。</p><h3 id="HTTP-1-0-vs-HTTP-1-1"><a href="#HTTP-1-0-vs-HTTP-1-1" class="headerlink" title="HTTP 1.0 vs HTTP 1.1"></a>HTTP 1.0 vs HTTP 1.1</h3><ol><li>在HTTP1.0中，默认使用短连接；1.1中默认使用长连接，可采用流水线方式。</li><li>新增了24个错误状态响应码</li><li>HTTP1.1在请求头加入了range，允许只请求资源的某个部分，减少浪费带宽的现象</li><li>HTTP1.0主要使用header里的<code>If-Modified-Since</code>,<code>Expires</code>作为缓存判断的标准，而1.1提供了更多缓存头控制缓存策略。</li></ol><h3 id="HTTP-1-1-vs-HTTP-2-0"><a href="#HTTP-1-1-vs-HTTP-2-0" class="headerlink" title="HTTP 1.1 vs HTTP 2.0"></a>HTTP 1.1 vs HTTP 2.0</h3><ol><li>实现多路复用，一个连接并发处理多个请求，1.1是采用多个TCP连接实现处理多个请求。</li><li>2.0对头部数据进行压缩</li><li>允许服务器推送资源到浏览器，改善延迟。</li></ol><h3 id="HTTP-2-0-vs-HTTP-3"><a href="#HTTP-2-0-vs-HTTP-3" class="headerlink" title="HTTP 2.0 vs HTTP 3"></a>HTTP 2.0 vs HTTP 3</h3><ol><li>升级了TLS和头部压缩算法</li><li>将HTTP下层的TCP改为了UDP</li></ol><h3 id="HTTP如何保存用户状态"><a href="#HTTP如何保存用户状态" class="headerlink" title="HTTP如何保存用户状态?"></a>HTTP如何保存用户状态?</h3><p>​    Session为HTTP协议解决了这个问题，服务器端为特定用户创建特定的Session之后就可以标识并跟踪该用户了。Session可以用内存和数据库保存。</p><p>​    可以通过向Cookie中附加一个Session ID来跟踪Session。Cookie一般用于保存用户信息，比如保持登录之类，保存在客户端；Session是通过服务端记录用户状态，保存在服务器端。</p><h3 id="浏览器键入URL地址这个过程发生了什么"><a href="#浏览器键入URL地址这个过程发生了什么" class="headerlink" title="浏览器键入URL地址这个过程发生了什么"></a>浏览器键入URL地址这个过程发生了什么</h3><p>​    总体分为DNS解析、TCP连接、发送HTTP请求、服务器处理并返回报文、浏览器解释渲染页面、连接结束这几个过程。</p><h4 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h4><p>​    DNS解析是一个递归查询的过程，首先会在本地域名服务器中查询，查询不到则向根域名服务器发送请求，查询不到则向顶级域名服务器发送请求，直至查到。随后本地域名服务器将IP地址缓存到本地。</p><h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>​    三次握手后建立数据传输</p><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><p>​    构建HTTP请求报文并通过TCP协议发送至服务器指定端口，由三部分组成，请求头，请求报头和请求正文。</p><h4 id="处理请求并返回报文"><a href="#处理请求并返回报文" class="headerlink" title="处理请求并返回报文"></a>处理请求并返回报文</h4><p>​    按照报文格式进一步封装为HTTP Request对象，由状态码、响应报头和响应报文组成。</p><h2 id="SMTP（简单邮件发送协议）"><a href="#SMTP（简单邮件发送协议）" class="headerlink" title="SMTP（简单邮件发送协议）"></a>SMTP（简单邮件发送协议）</h2><p>​    基于TCP协议用来发送电子邮件</p><h3 id="邮件发送过程"><a href="#邮件发送过程" class="headerlink" title="邮件发送过程"></a>邮件发送过程</h3><p>​    客户将写好的邮件信息发送给SMTP服务器，服务器使用SMTP协议转发邮件到指定邮箱服务器，等待用户使用POP3/IMAP协议取邮件。</p><h2 id="POP3-IMAP（邮件接收协议）"><a href="#POP3-IMAP（邮件接收协议）" class="headerlink" title="POP3/IMAP（邮件接收协议）"></a>POP3/IMAP（邮件接收协议）</h2><ol><li><p>POP有两种工作方式</p><ul><li><p>删除：每次读取邮件后就删除该邮件</p></li><li><p>保存：读取邮件后继续保存</p></li></ul></li><li><p>IMAP</p><ul><li>客户端和邮箱可以实现同步</li></ul></li></ol><h2 id="FTP（文件传输协议）"><a href="#FTP（文件传输协议）" class="headerlink" title="FTP（文件传输协议）"></a>FTP（文件传输协议）</h2><p>​    基于TCP协议，在通信主机间使用两条TCP连接，一条用于传输控制信息、一条用于数据传送，提高了FTP的效率。</p><h2 id="Telnet（远程登陆协议）"><a href="#Telnet（远程登陆协议）" class="headerlink" title="Telnet（远程登陆协议）"></a>Telnet（远程登陆协议）</h2><p>​    基于TCP，但所有数据明文发送，有安全问题。</p><h2 id="SSH（安全网络传输协议）"><a href="#SSH（安全网络传输协议）" class="headerlink" title="SSH（安全网络传输协议）"></a>SSH（安全网络传输协议）</h2><p>​    对传输数据进行加密以保证数据安全性，可有效防止远程管理中的信息泄露问题。</p><h1 id="二、运输层"><a href="#二、运输层" class="headerlink" title="二、运输层"></a>二、运输层</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h3><table><thead><tr><th align="center">名称</th><th></th></tr></thead><tbody><tr><td align="center">源端口和目的端口</td><td></td></tr><tr><td align="center">序号（seq）</td><td>每个字节都按顺序编号</td></tr><tr><td align="center">确认号</td><td></td></tr><tr><td align="center">数据偏移</td><td></td></tr><tr><td align="center">紧急URG</td><td>当URG=1，当前字段有效</td></tr><tr><td align="center">确认ACK</td><td>仅ACK=1，当前字段有效；连接建立后，所有报文传输ACK=1</td></tr><tr><td align="center">同步SYN</td><td>SYN=1，ACK=0是连接请求报文；同意连接后，SYN=1，ACK=1</td></tr><tr><td align="center">终止FIN</td><td>FIN=1，发送方数据发送完毕，要求释放</td></tr></tbody></table><h3 id="三次握手、四次挥手"><a href="#三次握手、四次挥手" class="headerlink" title="三次握手、四次挥手"></a>三次握手、四次挥手</h3><pre class="mermaid">sequenceDiagram    客户端->>服务器: SYN=1 seq=x(随机选择)    服务器->>客户端: SYN=1 ACK=1 seq=y ack=x+1    客户端->>服务器: ACK=1 seq=x+1 ack=y+1</pre><h4 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h4><p>​    三次握手的目的在于建立可靠的通信传输，双方都必须确认自己和对方的发送和接受是正常的。</p><p>​    两次握手：客户发送请求、seq=client_isn；服务器确认客户发来的seq，自己的seq=server_isn。这样只对客户的起始序列号达成同步，对服务器的起始序列号没有同步，无法达成可靠连接。</p><p>​    四次握手：客户发送请求、seq=client_isn；服务器确认客户seq，并发送ack=client_isn+1；服务器发送seq=server_isn；客户端确认服务器seq，发送ack=server_isn+1。其中23步可以合并，提高连接效率和速度。</p><h4 id="二次握手回传SYN的意义"><a href="#二次握手回传SYN的意义" class="headerlink" title="二次握手回传SYN的意义"></a>二次握手回传SYN的意义</h4><p>​    ACK是为了告知发送方，你的发送是正常的，回传SYN是为了确定自己的发送没问题。</p><h4 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h4><pre class="mermaid">sequenceDiagram    客户端->>服务器: FIN(1)    服务器->>客户端: ACK(2)    服务器->>客户端: FIN(3)    客户端->>服务器: ACK(4)</pre><p>​    (1)客户端进入FIN_WAIT_1状态</p><p>​    (2)服务器进入CLOSE_WAIT状态，客户端接收到ACK后进入FIN_WAIT_2状态    </p><p>​    (3)服务器进入LAST_ACK状态</p><p>​    (4)客户端进入TIME_WAIT状态，服务器接收到ACK后进入CLOSED状态，完成关闭；客户端在<strong>2MSL</strong>后进入CLOSED状态完成关闭。</p><blockquote><p>为什么TIME_WAIT等2MSL？</p><p>MSL是报文最大生存时。</p><p>为保证客户端发送的最后一个ACK能够到达服务器端，因为ACK可能会丢失（接收到ACK后还要发送FIN）；使得本次TCP连接中的所有报文小时。</p></blockquote><p>​    在握手时，服务器将ACK和SYN放在一个报文里交给了客户端；但关闭连接时，对方首先发过来一个FIN，表示不再发送数据，但可以继续接受数据，服务器可以选择发送数据或直接关闭，故ACK和FIN是分开发送的。</p><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>​    TCP设置有保活计时器，服务器每接收到一个客户端的请求是，该计时器都会复位，到时间后，每隔75s向客户端发送探测报文段，若连发10个都毫无反应，服务器就关闭连接。</p><h3 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol><li>TCP面向连接，UDP无连接</li><li>TCP提供可靠数据传输，UDP不保证可靠交付</li><li>TCP以字节流形式传输，UDP用数据报文段传输，且不提供拥塞控制</li><li>TCP首部开销20个字节，UDP8个字节</li><li>TCP不提供广播或多播，只能实现点到点，UDP支持一对一，一对多，多对一，多对多的交互通信</li><li>TCP一般用于文件传输、发送邮件、远程登陆等，UDP在即时通信方面有优势。</li></ol><h3 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h3><blockquote><p>为了防止过多的数据进入网络，使得路由器/链路不致过载</p></blockquote><p>TCP发送方要维持一个拥塞窗口（cwnd）的动态变量，发送窗口取值为cwnd和接收方的接收窗口较小的一个。</p><ul><li>慢开始：由小到大逐渐增大发送窗口，每一轮cwnd加倍</li><li>拥塞避免：拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1</li><li>快重传和快恢复：如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统高频问题总结</title>
      <link href="/2022/03/24/220324-2/"/>
      <url>/2022/03/24/220324-2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、OS是什么"><a href="#一、OS是什么" class="headerlink" title="一、OS是什么"></a>一、OS是什么</h1><p>OS（operating system）本质上是个软件程序，用于管理计算机软件资源和硬件资源，它屏蔽了硬件层的复杂性，Kernel（内核）是它的核心，负责系统内存管理，硬件设备管理，文件系统管理，应用程序管理。</p><pre class="mermaid">graph TD;A[应用]-->B[Kernel]B-->AB-->C[CPU]B-->D[Memory]B-->E[Devices]</pre><h1 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h1><p>进程是资源调度的基本单位，它拥有资源；</p><p>线程是独立调度的基本单位，只能访问所属进程的资源。</p><h2 id="进程的五种状态"><a href="#进程的五种状态" class="headerlink" title="进程的五种状态"></a>进程的五种状态</h2><pre class="mermaid">graph LR;A[new]-->B[ready]B-->C[running]C-->BD[waiting]-->BC-->DC-->E[terminated]</pre><p><em>图有点歪了</em></p><table><thead><tr><th>状态转换</th><th>所作操作</th></tr></thead><tbody><tr><td>ready（就绪状态）–&gt; running（运行状态）</td><td>通过调度算法获得时间片</td></tr><tr><td>running（运行状态）–&gt; ready（就绪状态）</td><td>时间片耗尽</td></tr><tr><td>running（运行状态）–&gt; waiting（阻塞状态）</td><td>缺少所需资源（并不包括时间片）</td></tr><tr><td>waiting（阻塞状态）–&gt;running（运行状态）</td><td>等待的时间发生</td></tr></tbody></table><h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><ol><li>管道/无名管道：用于父子、兄弟进程间的通信</li><li>有名管道：用于任意两个进程间的通信</li><li>信号：通知接受进程某个事件已经发生，可以在任意时刻发送。当目的进程未在running态，信号保存在内核中，随后传递；当目的进程处在阻塞态时，传递延迟，直至阻塞取消并再次传递。</li><li>消息队列：是消息的链表，存放在内核中。克服了信号承载信息量少，管道只能承载无格式字节流和缓冲区大小受限等缺点。</li><li>信号量：允许多进程访问同一资源，为了解决进程同步问题。</li><li>共享内存：多个进程可访问同一块空间。</li><li>套接字：客户端和服务器可通过网络直接通信。</li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ol><li>先到先服务（FCFS）：按请求顺序进行调度。</li><li>短作业优先（SJF）：按估计运行时间调度，长作业可能会被饿死。</li><li>最短剩余时间优先（SRTN）：抢占式SJF</li><li>时间片轮转调度：按照FCFS排序，将时间片分给队首，耗尽后中断当前进程执行，将队首进程送往队尾，继续将时间片分给队首</li><li>优先级调度：为每个进程分配优先级。同优先级按FCFS。</li><li>多级反馈队列：结合了4.5 UNIX采用此种调度。</li></ol><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>New：构造了Thread实例，还没有被start</p><p>RUNNABLE：线程正在运行或正等待被CPU执行</p><p>BLOCKED：线程调用synchronized关键字等待获取monitor锁</p><p>WAITING：调用了无超时的wait、join、park方法</p><p>TIMED_WAITING：线程调用了有超时的wait、sleep、join、parkNanos、parkUntil方法</p><p>Terminated：线程终止/完成了运行</p><h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><p>​    死锁是指多个进程在运行过程中因争夺资源造成的僵局，当进程处于僵持状态时，若无外力作用，二者将无法向前推进。</p><pre class="mermaid">graph TD;A(Thread A)-->|持有|B[Lock A]A-->|等待获取|DC(Thread B)-->|持有|D[Lock B]C-->|等待获取|B</pre><h2 id="为何会产生死锁？"><a href="#为何会产生死锁？" class="headerlink" title="为何会产生死锁？"></a>为何会产生死锁？</h2><ol><li><p>竞争资源</p><blockquote><p>系统中的资源可以分为两类</p><p>可剥夺性资源：进程获得后可被剥夺，例如CPU和主存</p><p>不可剥夺资源：分配后，系统不能强行收回，只能由进程自行释放</p></blockquote><p>​    一般是由于竞争不可剥夺资源或者临时资源（硬件中断、信号、消息队列、缓冲区消息等）通常消息通信顺序进行不当，则会产生死锁</p></li><li><p>进程间推进顺序非法</p><p>如上图，Thread A请求Lock B时，因为被Thread B占用而阻塞，反之同理，于是发生死锁</p></li></ol><h2 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h2><p><strong>四个必要条件</strong></p><ul><li>互斥条件：某资源在一段时间内仅为一个进程所占用</li><li>请求和保持条件：当进程请求资源阻塞时，对已持有的资源不放手</li><li>不剥夺条件：已持有的资源在未使用前，不能被剥夺，只能由进程自己使用完释放</li><li>环路等待条件：发生死锁时，必然存在一个进程–&gt;资源的环形链</li></ul><h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><h3 id="预防死锁-保证系统不会进入死锁状态"><a href="#预防死锁-保证系统不会进入死锁状态" class="headerlink" title="预防死锁-保证系统不会进入死锁状态"></a>预防死锁-保证系统不会进入死锁状态</h3><blockquote><p>即破坏四个必要条件中的任意一条即可</p></blockquote><ol><li>一次性分配所有资源，破坏请求条件</li><li>只要有资源得不到分配，就不给这个进程分配资源，破坏保持条件</li><li>当某进程仅能获得部分资源，释放已占有的资源，破坏不可剥夺条件</li><li>资源有序分配，进程按照资源编号递增的顺序请求，释放按照递减的顺序，破坏环路等待条件</li></ol><h3 id="避免死锁-判断分配资源是否会产生死锁"><a href="#避免死锁-判断分配资源是否会产生死锁" class="headerlink" title="避免死锁-判断分配资源是否会产生死锁"></a>避免死锁-判断分配资源是否会产生死锁</h3><blockquote><p>上述的几种方式会损害系统性能，故可采用银行家算法避免死锁。它改善了资源利用率的问题，但由于要检测资源占用和申请情况，以及安全性检查，需要耗费较多时间。</p></blockquote><p>​    <a href="https://blog.csdn.net/qq_33414271/article/details/80245715">银行家算法</a>：当一个进程申请使用资源时，先试探性地分配给该进程资源，随后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，进程继续等待。</p><p>​    那么如何判断系统安全呢，如果A申请X个资源，如果X&lt;空闲资源，接着判断分配X个资源后，剩余的资源能否支撑进程队列的某个进程执行完毕，若没有这样的进程存在，则系统不安全；若可支撑所有进程都可以执行完毕，则系统处于安全状态，根据分配顺序生成安全序列，可避免系统存在潜在死锁的风险</p><p>算法举例：</p><p>有3种资源 A有17个，B有5个，C有20个</p><table><thead><tr><th></th><th>最大资源需求量A B C</th><th>已分配资源量A B C</th></tr></thead><tbody><tr><td>P1</td><td>5             5                9</td><td>2              1            2</td></tr><tr><td>P2</td><td>5             3                6</td><td>4              0            2</td></tr><tr><td>P3</td><td>4             0               11</td><td>4              0           5</td></tr><tr><td>P4</td><td>4             2                 5</td><td>2              0            4</td></tr><tr><td>P5</td><td>4             2                 4</td><td>3              1             4</td></tr></tbody></table><blockquote><p><strong>可利用资源Available （每一类可利用的资源数目）、最大需求矩阵Max（每一个进程对某类资源的最大需求）、分配Allocation（已分配给每一进程的资源数），需求Need（每一个进程还需要的各类资源数）</strong></p></blockquote><p>​    当前系统状态：</p><table><thead><tr><th></th><th>Max</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td>P1</td><td>5 5 9</td><td>2 1 2</td><td>3 4 7</td><td>2 3 3</td></tr><tr><td>P2</td><td>5 3 6</td><td>4 0 2</td><td>1 3 4</td><td></td></tr><tr><td>P3</td><td>4 0 11</td><td>4 0 5</td><td>0 0 6</td><td></td></tr><tr><td>P4</td><td>4 2 5</td><td>2 0 4</td><td>2  2 1</td><td></td></tr><tr><td>P5</td><td>4 2 4</td><td>3 1 4</td><td>1 1 0</td><td></td></tr></tbody></table><p>​    此时因为Available中的每一项都大于(Need,P5)，所以先执行P5。</p><table><thead><tr><th></th><th>work</th><th>Need</th><th>Allocation</th><th>work+Allocation</th><th>finish</th></tr></thead><tbody><tr><td>P5</td><td>2 3 3</td><td>1 1 0</td><td>3 1 4</td><td>5 4 7</td><td>true</td></tr><tr><td>P4</td><td>5 4 7</td><td>2 2 1</td><td>2 0 4</td><td>7 4 11</td><td>true</td></tr><tr><td>P1</td><td>7 4 11</td><td>3 4 7</td><td>2 1 2</td><td>9 5 13</td><td>true</td></tr><tr><td>P3</td><td>9 5 13</td><td>0 0 6</td><td>4 0 5</td><td>13 5 18</td><td>true</td></tr><tr><td>P2</td><td>13 5 18</td><td>1 3 4</td><td>4 0 2</td><td>17 5 20</td><td>true</td></tr></tbody></table><h3 id="检测、解除死锁"><a href="#检测、解除死锁" class="headerlink" title="检测、解除死锁"></a>检测、解除死锁</h3><p>通过进程-资源分配图检测系统是否处于死锁状态。</p><ul><li>若图中无环路，则无死锁</li><li>若图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁</li><li>若有环路，资源类有多个资源，则系统未必会发生死锁，如果能找出一个既不阻塞又非独立的进程（类似拓扑排序）,归还所有资源，则不会发生死锁，否则会发生死锁。</li></ul><p>死锁的解除：</p><ul><li>结束所有进程、重新启动操作系统</li><li>撤销涉及思索的所有进程，接触死锁后继续</li><li>逐个撤销涉及死锁的进程，回收资源直至死锁解除</li><li>从涉及死锁的几个进程中抢占资源，夺取后分配给涉及死锁的进程直至死锁解除</li></ul><h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><p>​    内存管理涉及内存的分配和回收、地址转换（逻辑地址-&gt;物理地址）</p><h2 id="管理机制"><a href="#管理机制" class="headerlink" title="管理机制"></a>管理机制</h2><ul><li><p>连续分配管理 ，它为用户程序分配了连续的内存空间，例如块式管理，它将内存划分为固定大小，块中未使用的空间被称为碎片</p></li><li><p>非连续分配管理，允许内存分散。</p><ul><li><p>页式管理，将内存分成一页页大小固定的形式，通过页表管理地址，页较小，没有实际意义。</p><ol><li><p>为了加快虚拟地址转换物理地址的速度，引入了<strong>快表</strong>，是一种特殊高速缓冲存储器，存储了页表的一部分/全部，提高了访问速度</p><p>流程：</p><ul><li>根据虚拟地址页号查找快表</li><li>在快表中，读取物理地址；不在快表内，到页表中查询，随后将映射项添加至快表</li><li>当快表填满后，按照一定的策略淘汰掉快表中的一页</li></ul></li><li><p>引入<strong>多级页表</strong>解决页表大的问题，用时间换空间，避免把全部页表一直放在内存中占用过多空间。</p><blockquote><p>多级页表如何节约内存？</p><p><a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">这篇</a></p></blockquote></li></ol></li><li><p>段式管理，将内存分成一段段的，它具有实际意义，比如主程序段MAIN，子程序段X，数据段D，栈段S，通过段表管理地址。</p></li><li><p>段页式管理机制，结合段式管理和页式管理，先分成若干段，段又分成页。</p></li></ul></li></ul><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>​    逻辑地址由操作系统决定，物理地址是指内存地址寄存器中的地址，是内存单元真正的地址。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存为每个进程提供了一个一致的、私有的地址空间（是连续完整的内存空间），虚拟内存空间会存在硬盘中，会被内存缓存，有的操作系统还会再内存不够时，将某一进程的内存全部放入硬盘空间中，<strong>切换进程时再从硬盘读取</strong>。</p><p><strong>CPU寻址</strong></p><p>现代处理器使用虚拟寻址的寻址方式，CPU需要使用MMU（内存管理单元）将虚拟地址翻译成物理地址，访问到真实的物理内存，MMU需要借助页表来动态翻译。</p><p><strong>局部性原理</strong></p><ul><li>时间局部性：某条指令/某数据刚刚被执行或访问过，则它不久后可能会被再次访问</li><li>空间局部性：程序访问某个存储单元，不久后，其附近的存储单元也即将被访问。</li></ul><p><strong>虚拟存储器</strong></p><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，<em>由操作系统将所需要的部分调入内存</em>，然后继续执行程序。另一方面，<em>操作系统将内存中暂时不使用的内容换到外存上</em>，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><ol><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>​    可以简单理解为淘汰页面的规则，地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p><blockquote><p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p></blockquote><p>​    当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。</p><ol><li>OPT页面置换（最佳页面）：保证被淘汰的页面将会是以后很久不用的，但无法实现，一般用于衡量其他置换算法</li><li>FIFO（先进先出）：淘汰最先进入内存的页面</li><li>LRU（最近最久未使用）：使用一个时间T来记录一个页面自上次被访问来所经历的时间，淘汰时选择T值最大的</li><li>LFU（最少使用页面置换算法）：淘汰在之前使用最少的页面</li></ol><p>（leetcode上有实现LRU和LFU的hard题，还没看过，感觉我春招买面的还没问到这个，因为我菜吧）</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/03/22/220322/"/>
      <url>/2022/03/22/220322/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>Redis是NoSQL数据库，使用C语言开发，常常应用于缓存、分布式锁、消息队列，支持事务、持久化、Lua脚本、多种集群方案。</p></blockquote><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><p><a href="https://redis.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/1-2-1-strings-in-redis/">可以看这个，Redis官网的文档</a></p><p>官网上并没有提供redis的windows版本，github有个大佬提供了，但可以试试这个官方提供的<a href="https://try.redis.io/">在线redis</a></p><p>将redis的存储单元看成一个盒子，下列类型都可作为值类型。</p><ul><li><p><code>String</code>:key和type位于盒子上方，value在盒子里面</p><blockquote><p>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作；</p><p>可以用来存储Byte、Integer、Floating-point类型的值，不能超过512MB</p></blockquote><p>它是一种简单动态字符串（SDS），通过预分配冗余空间的方式来减少内存的频繁分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">字符串操作</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET this:name youKnow</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET this:name 获取key所对应的值</span></span><br><span class="line">&quot;youKnow&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> exists this:name 判断key是否存在</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> exists this:na</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> strlen this:name key所存储的字符串值的长度</span></span><br><span class="line">(integer) 7</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> del this:name 删除key所对应的值</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> exists this:name</span> </span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get this:name</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">#</span><span class="bash">批量设置</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mset key1 val1 key2 val2</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mget key1 key2</span></span><br><span class="line">1) &quot;val1&quot;</span><br><span class="line">2) &quot;val2&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">计数器 不能超过Long.Max，不能低于Long.MIN</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCR val</span></span><br><span class="line">(integer) 11</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCR val</span></span><br><span class="line">(integer) 12</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DEL val</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCR val</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCRBY val 100</span></span><br><span class="line">(integer) 101</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DECR val</span></span><br><span class="line">(integer) 100</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DECRBY val 10</span></span><br><span class="line">(integer) 90</span><br><span class="line"><span class="meta">#</span><span class="bash">过期</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> key:lock <span class="string">&quot;dying&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> expire key:lock 60 <span class="comment">#设置60s后过期</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ttl key:lock <span class="comment">#查看时间</span></span></span><br><span class="line">(integer) 45</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> persist key:lock <span class="comment"># 取消过期</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ttl key:lock <span class="comment">#-1永不过期 -2已过期</span></span></span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure></li><li><p><code>List</code>:key和type位于盒子上方，list of valuse在盒子里</p><blockquote><p>可以从List两端压入或弹出元素，保留范围内元素</p></blockquote><p>List的实现为一个双向链表。支持反向查找和遍历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush people <span class="string">&quot;A&quot;</span>  <span class="string">&quot;B&quot;</span> <span class="comment">#左push</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lpush people <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span> <span class="string">&quot;E&quot;</span> <span class="comment">#右push</span></span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lpop people <span class="comment">#左弹出</span></span></span><br><span class="line">&quot;E&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange people 0 5</span></span><br><span class="line">1) &quot;D&quot;</span><br><span class="line">2) &quot;C&quot;</span><br><span class="line">3) &quot;A&quot;</span><br><span class="line">4) &quot;B&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange people 0 -1</span></span><br><span class="line">1) &quot;D&quot;</span><br><span class="line">2) &quot;C&quot;</span><br><span class="line">3) &quot;A&quot;</span><br><span class="line">4) &quot;B&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> llen people <span class="comment">#获取长度</span></span></span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></li><li><p><code>Set</code>：key和type位于盒子上方，list of valuse在盒子里</p><blockquote><p>无序集合,元素仅出现一次</p><p>添加、获取、移除元素，元素存在检查，获取所有</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD str <span class="string">&quot;ab&quot;</span> <span class="string">&quot;cd&quot;</span> <span class="string">&quot;ef&quot;</span> <span class="comment">#添加元素</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SREM str <span class="string">&quot;ab&quot;</span> <span class="comment">#移除元素</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> smembers str <span class="comment">#获取全部</span></span></span><br><span class="line">1) &quot;cd&quot;</span><br><span class="line">2) &quot;ef&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SISMEMBER str <span class="string">&quot;c&quot;</span> <span class="comment">#是否在set内</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD str2 <span class="string">&quot;gh&quot;</span> <span class="string">&quot;ij&quot;</span></span> </span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SUNION str str2 <span class="comment">#联合两个set</span></span></span><br><span class="line">1) &quot;cd&quot;</span><br><span class="line">2) &quot;gh&quot;</span><br><span class="line">3) &quot;ij&quot;</span><br><span class="line">4) &quot;ef&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>Hash</code>：<code>key name</code>和type在盒子上方，key-value在盒子里</p><blockquote><p>无序散列表</p><p>单独操作一个键值对，获取所有，元素存在检查</p></blockquote><p>类似JDK1.8之前的HashMap（数组+链表）hash是一个String类型field和value的映射表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> hmset infoKey name <span class="string">&quot;here&quot;</span> desc <span class="string">&quot;loc&quot;</span> age <span class="string">&quot;10&quot;</span></span> </span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hexists infoKey name <span class="comment">#是否存在该字段</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hget infoKey name <span class="comment">#获取字段值</span></span></span><br><span class="line">&quot;here&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hgetall infoKey <span class="comment">#获取所有键值对</span></span></span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;here&quot;</span><br><span class="line">3) &quot;desc&quot;</span><br><span class="line">4) &quot;loc&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hkeys infoKey <span class="comment">#获取所有键</span></span></span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;desc&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hvals infoKey <span class="comment">#获取所有值</span></span></span><br><span class="line">1) &quot;here&quot;</span><br><span class="line">2) &quot;loc&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hset infoKey name <span class="string">&quot;there&quot;</span> <span class="comment">#修改值</span></span></span><br><span class="line">0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hget infoKey name <span class="comment">#获取修改后的值</span></span></span><br><span class="line">&quot;there&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>sorted set（zset）</code>: <code>key name</code>和type在盒子上方，key-value在盒子里</p><blockquote><p>有序集合</p><p>操作单个元素，获取某一个区间内的元素，计算元素位置</p></blockquote><p>与set相比增加了一个权重参数score</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD hackers 1940 <span class="string">&quot;Alan Kay&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD hackers 1906 <span class="string">&quot;Grace Hopper&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD hackers 1953 <span class="string">&quot;Richard Stallman&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD hackers 1916 <span class="string">&quot;Claude Shannon&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zrange hackers 1 3 <span class="comment">#按权重排序输出</span></span></span><br><span class="line">1) &quot;Claude Shannon&quot;</span><br><span class="line">2) &quot;Alan Kay&quot;</span><br><span class="line">3) &quot;Richard Stallman&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zcard hackers <span class="comment">#查看元素数量</span></span></span><br><span class="line">4</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zscore hackers <span class="string">&quot;Alan Kay&quot;</span> <span class="comment">#查看某个value的权重</span></span></span><br><span class="line">1940.0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zrevrange hackers 0 -1 <span class="comment">#逆序输出某个范围内的元素</span></span></span><br><span class="line">1) &quot;Richard Stallman&quot;</span><br><span class="line">2) &quot;Alan Kay&quot;</span><br><span class="line">3) &quot;Claude Shannon&quot;</span><br><span class="line">4) &quot;Grace Hopper&quot;</span><br></pre></td></tr></table></figure></li></ul><p>任何二进制序列均可作为Key值，空字符串也是有效的。</p><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p><img data-src="/../../images/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p>如图所示</p><h2 id="三、redis与Memcached"><a href="#三、redis与Memcached" class="headerlink" title="三、redis与Memcached"></a>三、redis与Memcached</h2><ol><li><p>Memcached仅支持字符串类型，Redis支持五种数据类型；</p></li><li><p>Redis支持两种<strong>持久化</strong>，RDB快照和AOF日志，Memcached不支持持久化</p></li><li><p>Redis Cluster实现<strong>分布式</strong>的支持，Memcached不支持分布式</p></li><li><p>Redis可以将一些很久不用的value交换到磁盘，Memcached数据则会一直存在于内存中。Memcached将内存分割成特定长度的块来存储数据，用以解决内存碎片问题。</p></li></ol><h2 id="四、数据淘汰策略"><a href="#四、数据淘汰策略" class="headerlink" title="四、数据淘汰策略"></a>四、数据淘汰策略</h2><p>当内存使用量超出时，使用数据淘汰策略</p><table><thead><tr><th align="center">策略</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">volatile-lru</td><td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">volatile-ttl</td><td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td align="center">volatile-random</td><td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td align="center">allkeys-lru</td><td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">allkeys-random</td><td align="center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td align="center">noeviction</td><td align="center">禁止驱逐数据</td></tr></tbody></table><p>为保证缓存命中率，保证缓存中数据均为热点数据，可以将内存最大使用量设置为热点数据占用的内存量，使用allkey-lru淘汰策略，将最近最少使用的数据淘汰。</p><h2 id="五、持久化"><a href="#五、持久化" class="headerlink" title="五、持久化"></a>五、持久化</h2><p>redis提供两种方式进行持久化，RDB（将Redis在内存中的数据库记录写入磁盘）、AOF（append only file，将Redis操作日志以追加的方式写入文件）</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><pre class="mermaid">graph LRA[redis server] -->|fork子进程| B[child process]B -->|写入| C[RDB临时文件]</pre><p>定时fork子进程，将其写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p>优点：</p><ol><li>对文件备份很友好，灾难后恢复也很轻松，因为进行RDB持久化后，整个数据库将只包含一个文件；</li><li>性能最大化，相比AOF，它的启动效率更高。</li></ol><p>缺点：</p><ol><li>当系统在定时持久化之前出现宕机，此时未来得及写入磁盘的数据都将丢失；</li><li>当数据集较大时，整个服务器会停止服务几百ms。</li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><pre class="mermaid">graph LR;A(redis client)-->|发送写命令|B[redis server]B-->|同步写命令|C[AOF记录文件]</pre><p>处理每一个写、删操作，查询操作并不会记录，以文本方式记录。</p><p>优点：</p><ol><li><strong>更高的数据安全性</strong>，提供了三种同步策略，即每秒同步<code>everysec</code>、每修改同步<code>always</code>和不同步<code>no</code>。每秒同步的最差情况，当系统宕机时，这一秒钟内修改的数据将会丢失；每修改同步，可以将其视为同步持久化，但效率是最低的；</li><li>采用追加模式，即使宕机也不会破坏日志文件，<code>redis-check-aof</code>可以解决宕机引发的数据一致性问题；</li><li>如果日志过大，redis会自动启用rewrite机制，它会在append的时候，创建一个新的文件用于记录此期间有哪些修改命令被执行，可以更好地保证数据安全性；</li><li>此日志文件也可用于数据重建。</li></ol><p>缺点：</p><ol><li>恢复速度慢；</li><li>运行效率低；</li></ol><h2 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h2><p>redis的事务是<strong>非原子性</strong>的，不支持回滚；支持一次多个命令，均会被序列化入队，期间不会该去执行其他客户端的命令请求；没有隔离级别。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DISCARD #取消事务</span><br><span class="line">EXEC#执行事务</span><br><span class="line">MULTI#标记事务开始</span><br><span class="line">UNWATCH#取消对key监视</span><br><span class="line">WATCH#监视一个或多个key若key在事务执行前被改动，那么事务将会被打断。</span><br></pre></td></tr></table></figure><h2 id="七、事件"><a href="#七、事件" class="headerlink" title="七、事件"></a>七、事件</h2><p>Redis服务器是事件驱动程序，只关注网络IO和定时器，处理两类事件。</p><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><blockquote><p>用于处理Redis服务器和客户端之间的网络IO</p></blockquote><p>服务器通过套接字与客户端通信，文件事件是对套接字操作的抽象。redis使用了I/O多路复用程序同时监听多个套接字，并将到达的时间传送给文件时间分派其，分派其会根据套接字产生的事件类型调用相应的事件处理器。</p><blockquote><ul><li>监听套接字—-连接应答处理器</li><li>客户端套接字—-命令请求处理器</li><li>客户端套接字—-命令回复处理器</li><li>主从服务器复制—复制处理器</li></ul></blockquote><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><blockquote><p>Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</p></blockquote><p>事件由三个属性构成：</p><ul><li><p>id：服务器构建的全局唯一ID，递增</p></li><li><p>when：毫秒的UNIX时间戳，记录事件的到达时间</p></li><li><p>timeProc：时间事件处理器</p></li></ul><p>分为两类</p><ul><li>定时事件：程序在指定的时间之内执行一次</li><li>周期性事件：每隔指定时间就执行一次</li></ul><p>分类取决于时间事件处理器的返回值，<code>ae.h/AE_NOMORE</code>为定时事件，到达一次后被删除；返回整数值，为周期性事件，随后根据when更新。</p><p>时间事件被保存在一个无需链表中，每次执行要遍历链表，查找已到达的时间事件，并调用相应的事件处理器。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>由aeProcessEvents函数负责，置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数</p><h2 id="八、复制"><a href="#八、复制" class="headerlink" title="八、复制"></a>八、复制</h2><p>分布式系统中为了解决单点问题，将数据复制多个副本部署到其他机器，满足故障处理和负载均衡。<code>slaveof &#123;hostport&#125; &#123;postport&#125;</code>可以使得一个服务器成为另一个服务的从服务器，一从只能对一主，从节点也可以有从节点，从而实现嵌套。不支持主主复制。</p><p><a href="https://zhuanlan.zhihu.com/p/96191405">redis如何实现主从复制</a></p><p>主从复制的开启，完全是在从节点发起的，主节点无需任何动作。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><ol><li>从节点服务器需要使用<code>masterhost</code>和<code>masterport</code>存储主节点<code>ip</code>和<code>port</code>信息</li><li>建立socket连接</li><li>从节点向主节点ping，检查socket连接和主节点是否能处理请求</li><li>身份验证通过后，发送从节点端口信息</li></ol><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p><strong>从节点向主节点发送<code>pysnc</code>命令</strong>，根据主从节点当前状态不同，可能是全量复制/部分复制。</p><ol><li><p>全量复制</p><blockquote><p>用于初次复制或其它部分无法复制</p></blockquote><ul><li>经判断需要进行全量复制（如何判断看<code>runid</code>部分)</li><li>主节点执行bgsave，在后台生成RDB文件，使用复制缓冲区记录从现在开始的所有写命令</li><li>执行完成后，将RDB文件发送给从节点，从节点首先清除自己的旧数据，随后载入接收的RDB文件，更新数据库状态</li><li>将缓冲区的写命令发给从节点，执行后将数据库更新为最新状态</li><li>若从节点开启了AOF，会触发bgrewriteaof的执行，保证AOF始终是主节点的最新状态</li></ul></li><li><p>部分复制</p><blockquote><p>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，更加高效。</p></blockquote><p><code>offset</code>（复制偏移量）代表主节点向从节点传递的字节数；</p><p>复制挤压缓冲区是由主节点维护的、固定长度的的队列，开始于主节点有从节点，为了备份主节点最近发送给从节点的数据。</p><p><code>runid</code>（服务器运行ID），每个redis节点在启动会自动生成一个随机ID，用于识别唯一一个Redis节点。初次复制时，主节点会将这个runid发送给从节点。恢复重连后，从节点会将runid发给主节点进行比较。若一致，主节点将尝试使用部分复制（能否用还要看offset和缓冲区）；若不一致，只能进行全量复制。</p></li></ol><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>主节点将自己执行的写命令发送给从节点，从结点接受命令并执行，从而保证数据一致性。</p><h2 id="九、哨兵（sentinel）"><a href="#九、哨兵（sentinel）" class="headerlink" title="九、哨兵（sentinel）"></a>九、哨兵（sentinel）</h2><p>在复制的基础上，它实现了自动化的故障恢复和主节点的自动故障转移：在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer（九）</title>
      <link href="/2022/03/21/220321/"/>
      <url>/2022/03/21/220321/</url>
      
        <content type="html"><![CDATA[<p><b><font color=red>动态规划五部曲</font></b></p><a href="/2022/03/20/220320/" title="动态规划专题">动态规划专题</a><h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><blockquote><p>难度：中等</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote><p>这题虽然难度中等，但其实很简单。先确定<code>dp[i][j]</code>的含义，在<code>[i][j]</code>处能够取得<code>dp[i][j]</code>价值的礼物；再考虑初始化，<code>dp[0][0] = grid[0][0]</code>；接下来是转移方程，要得到最大值且只能向下或向右移动一格，意味着<code>dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + grid[i][j]</code>。其实在本题中，可以直接对grid进行修改，节省空间，无需另外开辟<code>m*n</code>的dp数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">        grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            grid[i][j] += Math.max(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><blockquote><p>难度：简单</p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p></blockquote><p>参考<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">本篇题解</a>，最后返回的值并非dp数组的最后一个状态，而是数组中最大的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(nums[i] + dp[i-<span class="number">1</span>],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; dp[i])&#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划专题</title>
      <link href="/2022/03/20/220320/"/>
      <url>/2022/03/20/220320/</url>
      
        <content type="html"><![CDATA[<p><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录中的动态规划</a> </p><ol><li>确定DP[i]的含义</li><li>确定DP初始化</li><li>确定转移方程</li><li>确定遍历方向</li><li>举例推导DP数组</li></ol><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4><blockquote><p>难度:中等</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p></blockquote><ol><li>DP[i] [j]意味着从（0，0）到（i，j）有dp[i] [j]种不同的路径；</li><li>举例可知，<code>1*1</code>，<code>1*2</code>，<code>1*3</code>，<code>2*1</code>，<code>3*1</code>都只有一种路线，故<code>DP[i][0] = 1</code>, <code>DP[0][j] = 1</code>；</li><li>因为机器人只能向下或向右移动一步，故机器人必定是从<code>dp[i][j-1]</code>或<code>dp[i-1][j]</code>处移动过来的，故<code>dp[i][j] = dp[i][j-1] + dp[i-1][j]</code>；</li><li>从上到下，从左到右依次遍历。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h4><blockquote><p>难度:中等</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p></blockquote><ol><li><code>DP[i][j]</code>意味着从（0，0）到（i，j）有<code>dp[i][j]</code>种不同的路径；</li><li>对于该dp数组的初始化，要考虑到obstacleGrid的情况。在逐行逐列初始化时，在<code>[i][0]</code>, <code>[0][j]</code>处碰到障碍物后，后面的方格都处于不可达状态，所以可以直接跳出该层的初始化；</li><li>而转移方程依旧是<code>dp[i][j] = dp[i][j-1] + dp[i-1][j]</code>；</li><li>从上到下，从左到右依次遍历。额外要注意的点在于，碰到障碍物时，直接跳过该点，因为不可达，所以无需改变状态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a></h4><blockquote><p>难度:中等751</p><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。返回你可以获得的最大乘积</p></blockquote><ol><li><code>DP[i]</code> 意味着数字i可以被拆分为的最大乘积为<code>dp[i]</code></li><li>对于dp初始化，因为<code>n&gt;=2</code>，<code>dp[0] dp[1]</code>不用考虑初始化，<code>dp[2] = 1</code>即可。</li><li>要得到分解后的最大乘积，先考虑将其拆为两个数的和，用<code>j</code>开始循环，循环到<code>i-j</code>结束，则<code>dp[i] = j * (i-j)</code>；再考虑将其拆成多个数的和，再计算乘积，<code>dp[i] = j * dp[i-j]</code>（其实相当于继续拆分<code>i-j</code>这个数）；每次循环都要与上次计算的<code>dp[i]</code>进行比较，故<code>dp[i] = max(dp[i],j*(i-j),j*dp[i-j])</code></li><li>从左到右依次遍历。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i-j;j++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer（八）</title>
      <link href="/2022/03/17/220317/"/>
      <url>/2022/03/17/220317/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><blockquote><p>难度:简单</p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p></blockquote><p> 第一反应递归，超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fibo(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> (fibo(n-<span class="number">1</span>)+fibo(n-<span class="number">2</span>))%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记忆化的递归，用HashMap记忆之前计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (map.get(n) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = (fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>))%<span class="number">1000000007</span>;</span><br><span class="line">        map.put(n,num);</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>吧还是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">            c = (a + b)%<span class="number">1000000007</span>;</span><br><span class="line">            a = b%<span class="number">1000000007</span>;</span><br><span class="line">            b = c%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><blockquote><p>难度：简单</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p></blockquote><p>整体思路类似斐波那契数列，但对于dp数组的初始化不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;dp[<span class="number">1</span>] = <span class="number">1</span>;dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; n+<span class="number">1</span>;i ++)&#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>]%<span class="number">1000000007</span>)+(dp[i-<span class="number">2</span>]%<span class="number">1000000007</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><blockquote><p>难度:中等227</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p></blockquote><p>使用贪心算法，遍历找出最小值，随后依次判断找出差值最大点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//贪心算法</span></span><br><span class="line">        <span class="keyword">int</span> low = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            low = Math.min(prices[i],low);</span><br><span class="line">            res = Math.max(prices[i] - low, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用动态规划写的还没太看懂，等看懂了补上。</p><p>有两种dp，dp[i]代表的意思有所不同。<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html#%E6%80%9D%E8%B7%AF">第一种</a>、<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/">第二种</a>，自己捋一捋思路，按照”五部曲”来确定dp数组以及初始化，还有转移方程。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer（七）</title>
      <link href="/2022/03/17/220316/"/>
      <url>/2022/03/17/220316/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指Offer-27-二叉树的镜像"><a href="#剑指Offer-27-二叉树的镜像" class="headerlink" title="剑指Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指Offer 27. 二叉树的镜像</a></h4><blockquote><p>难度：简单</p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p></blockquote><p>思路很简单，采用递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = mirrorTree(root.left);</span><br><span class="line">        TreeNode right = mirrorTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还思考过遍历每个结点，并交换左右节点这个做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.add(node.right);</span><br><span class="line">            TreeNode tmp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-28-对称的二叉树"><a href="#剑指Offer-28-对称的二叉树" class="headerlink" title="剑指Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指Offer 28. 对称的二叉树</a></h4><blockquote><p>难度:简单</p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p></blockquote><p>首先想到利用上题先得的一个镜像的二叉树，再逐一比较。</p><p>但始终AC不了， <code>[1,2,2,null,3,null,3]，[123]</code>这种测试用例过不去，找不到问题所在。。。就还是用递归完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">true</span> : isEqual(root.left,root.right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(TreeNode a, TreeNode b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> &amp;&amp; b == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || b == <span class="keyword">null</span> || a.val != b.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isEqual(a.left,b.right)&amp;&amp;isEqual(a.right,b.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><blockquote><p>难度:中等</p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p></blockquote><p>开始只想到了要先在A中找到B的结点，随后判断，但实现起来还是有困难，看了<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/">大佬题解</a>后豁然开朗，代码写的好简洁，易于理解。我写的好像一堆💩…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A!=<span class="keyword">null</span> &amp;&amp; B!=<span class="keyword">null</span>) &amp;&amp; (findB(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">findB</span><span class="params">(TreeNode A,TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> findB(A.left,B.left)&amp;&amp;findB(A.right,B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer（六）</title>
      <link href="/2022/03/15/220315/"/>
      <url>/2022/03/15/220315/</url>
      
        <content type="html"><![CDATA[<h4 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a></h4><blockquote><p>难度:中等</p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p></blockquote><p> 一个二叉树的层序遍历，借助队列的FIFO特性实现。</p><ol><li>判断根节点是否为空，为空则输出一个空集合；不为空则将根节点加入队列</li><li>输出队首元素，判断队首元素有无左右结点，若有，则加入队列</li><li>循环直至队列为空。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;()&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; res.size();i++)&#123;</span><br><span class="line">            arr[i] = res.get(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><blockquote><p>难度:简单</p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p></blockquote><p>感觉脑子不太够用了。。。和上道题类似，也是层序遍历，唯一不同的点在于，一层的节点要打印在同层。返回的结构是<code>List&lt;List&lt;Integer&gt;&gt;</code>，是由list组成的list集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; tree = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) tree.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!tree.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用以记录当前层的结果</span></span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = tree.size();i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node = tree.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) tree.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) tree.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><blockquote><p>难度:中等</p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p></blockquote><p>我的做法是采用 j 记录当前层数，偶数层进行翻转后添加至list。参看k神的<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/">题解</a>，在while循环体内加入判断当前层数的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; tree = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) tree.add(root);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!tree.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用以记录当前层的结果</span></span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = tree.size();i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node = tree.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) tree.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) tree.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                Collections.reverse(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（五）</title>
      <link href="/2022/03/14/220314/"/>
      <url>/2022/03/14/220314/</url>
      
        <content type="html"><![CDATA[<h3 id="剑指Offer-day04"><a href="#剑指Offer-day04" class="headerlink" title="剑指Offer day04"></a>剑指Offer day04</h3><h4 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">04. 二维数组中的查找</a></h4><blockquote><p>难度：中等</p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(column == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">            <span class="comment">//每一行的最大最小值确定区间</span></span><br><span class="line">            <span class="keyword">int</span> low = matrix[i][<span class="number">0</span>], high = matrix[i][column-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(target == low || target == high)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; low &amp;&amp; target &lt; high)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; column;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == matrix[i][j])&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比较暴力的解法，只是根据每一行最大最小值缩减了一下查找范围，[[]]，[]这两个测试用例也是很绝。</p><p>个人觉得很厉害的解法<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">类似二叉搜索树</a>，将矩阵逆时针旋转45°，将矩阵右上角/左下角的点看作根结点，与target进行比较，再进行相应的移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> row = matrix.length-<span class="number">1</span>, col = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt; matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">        row--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h4 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">11. 旋转数组的最小数字</a></h4><blockquote><p>难度：简单</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为1。 </p></blockquote><p>这题在力扣题库里是hard难度，不知道为啥这变了easy。一开始没啥思路，用几道类似的题</p><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a>（采取二分法，则一定有一半数字是有序的）</p><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组II</a>(可能会有重复元素，碰到 left=mid时，left要向后挪一个位置)</p><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a>这篇<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">题解</a>解释了为什么要比较mid和right而不是比较mid和left</p><p>看完以上三道题，本题就会很简单，相当于两道题的结合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] == numbers[r])&#123;</span><br><span class="line">                r --;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &lt; numbers[r])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">50. 第一个只出现一次的字符</a></h4><blockquote><p>难度：简单</p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p></blockquote><p>我的解法：数组下标对应字符，数字代表出现字数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            res[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还可以利用HashMap做映射，在第一次循环时，若该字符不在Map内，加入Map，value为对应pos。若非第一次出现，则将对应value置为-1。第二次循环Map的entry对即可，找出不为-1的最小值，返回对应字符，找不到则返回空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                map.put(s.charAt(i),-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(s.charAt(i),i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(cnt != -<span class="number">1</span> &amp;&amp; cnt &lt; min)&#123;</span><br><span class="line">                min = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == n ? <span class="string">&#x27; &#x27;</span> : s.charAt(min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（四）</title>
      <link href="/2022/01/17/220116/"/>
      <url>/2022/01/17/220116/</url>
      
        <content type="html"><![CDATA[<p><b><font color=red>有序数组的搜索问题优先考虑二分法</font></b></p><a href="/2022/01/02/220102/" title="二分法查找">二分法查找</a><h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">03. 数组中重复的数字</a></h4><blockquote><p>难度：简单</p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><p>看到不重复，想到HashSet，利用hashset元素不重复的特性，找出重复数字，但其实用Map也是一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashSet.contains(c))&#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashSet.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效率不高，但回过头想，可以将数组中的数看成一个个下标，利用新数组对应下标中存放的数来确定数字是否重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[n]==<span class="number">0</span>)&#123;</span><br><span class="line">                map[n] = -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="53-I-在排序数组中查找数字-I"><a href="#53-I-在排序数组中查找数字-I" class="headerlink" title="53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">53 - I. 在排序数组中查找数字 I</a></h4><blockquote><p>难度：简单</p><p>统计一个数字在排序数组中出现的次数。</p></blockquote><p>嗯…看到这个题直接用Map重拳出击了，看了看评论区原来考的是二分法…</p><p>Map写法过是过了，但时间效率很慢。优化后的Map写法也在其中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(n))&#123;</span><br><span class="line">                map.put(n,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(n,map.get(n)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(target)==<span class="number">0</span>?<span class="number">0</span>:map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化的Map</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n == target)&#123;</span><br><span class="line">                map.put(target,map.getOrDefault(target,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(target,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>我写出的二分法是，从两边分别找，找到target之后，再从mid出发，向前向后，在[low , mid]，[mid , high]之间寻找有多少个target。因为数组有序，所以target必在这两个区间之内。（再想想就和大佬两次二分思路差不多了！！！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(temp &gt;= low &amp;&amp; nums[temp] == target) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (temp &lt;= high &amp;&amp; nums[temp] == target) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了评论区，有大佬用了两次二分找到区间，直接计算得出个数。</p><h4 id="53-II-0～n-1中缺失的数字"><a href="#53-II-0～n-1中缺失的数字" class="headerlink" title="53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">53 - II. 0～n-1中缺失的数字</a></h4><blockquote><p>难度：简单</p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p></blockquote><p>我…又创建了个数组，按下标写的…其实根本不用创建新数组，只需要比较下标与当前数字是否相同…其实考的又是二分…</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:nums)&#123;</span><br><span class="line">            number[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不创建新数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有更秀的，等差数组求和再减出差值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:nums)&#123;</span><br><span class="line">            sum -= c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（三）</title>
      <link href="/2022/01/13/220112-2/"/>
      <url>/2022/01/13/220112-2/</url>
      
        <content type="html"><![CDATA[<h4 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></h4><blockquote><p>难度：简单</p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p></blockquote><p>Java中字符串不可变，可以循环字符串再向StringBuffer中添加元素。字符串也可以直接拼接，但开销略大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                stringBuffer.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stringBuffer.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也可以采用静态数组的方法，也有两种创建方法。第一种先行遍历字符串，创建3*size大小的数组（考虑最坏情况，每个字符都是空格）；第二种方法，遍历字符串统计空格个数，按需创建数组。</p><h4 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title="58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">58 - II. 左旋转字符串</a></h4><blockquote><p>难度：简单</p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p></blockquote><p><em>终于碰到个Java能一行代码搞定的简单题，每次看python一行解决就很羡慕。</em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n,s.length())+s.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法不取巧，不用截取函数。创建新的StringBuffer，按顺序添加字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//还有个很秀的操作，取余</span></span><br><span class="line">        <span class="comment">//for(int i = n; i &lt; n + s.length(); i++)</span></span><br><span class="line">        <span class="comment">//    res.append(s.charAt(i % s.length()));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; s.length(); i++)</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用String的 ‘+’ 添加字符，会产生多余开销。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（二）</title>
      <link href="/2022/01/12/220112-1/"/>
      <url>/2022/01/12/220112-1/</url>
      
        <content type="html"><![CDATA[<h4 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">06. 从尾到头打印链表</a></h4><blockquote><p>难度：简单</p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p></blockquote><p>从尾到头反过来可以利用栈先进后出的特性实现，同样，也可以将链表的每个结点值先遍历一遍，存入数组，利用数组可以利用下标取数的特性倒着取。</p><ol><li>利用栈的特点实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(temp.val);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            res[i] = list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用数组实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">24. 反转链表</a></h4><blockquote><p>难度：简单</p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p></blockquote><p>我第一个想法是循环链表，将每个节点头插到head之前，并更新newHead指针。<strong>不过需要注意一个问题，当head为空时，可以不用判断直接返回null。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>, newHead = head;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//newHead为反转链表头结点</span></span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next = temp.next;</span><br><span class="line">            temp.next = newHead;</span><br><span class="line">            newHead = temp;</span><br><span class="line">            temp = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后看了看评论区和官方题解，主要有迭代和递归两种做法。<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/shi-pin-jiang-jie-die-dai-he-di-gui-hen-w2gm0/">推荐一篇讲解</a>。</p><p>迭代的思想主要是利用两个指针每次反转两个结点，并不断向后移动。pre指向null，curr指向head。当head.next指向null时，头结点反转完成，但与后续链表断开。所以需要一个next在翻转之前指向head.next以保持连接。</p><pre class="mermaid">graph LR;A[head]-->B[ListNode A]B-->C[null]</pre><p>头结点反转完成后如图：</p><pre class="mermaid">graph RL;A[head]-->D[null]</pre><p>核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    ListNode next = curr.next;</span><br><span class="line">    curr.next = pre;</span><br><span class="line">    pre = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的过程，就是将一个大问题划分为小问题再进行归并。当链表仅有一个头结点或无结点时可以直接返回head，这就是递归推出的条件。而递归进行的过程，可以参考有两个结点时，无需使用额外指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ||head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">35. 复杂链表的复制</a></h4><blockquote><p>难度：中等</p><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p></blockquote><p>开始甚至没看懂题，还想着直接返回head。</p><p>官方题解有点看不懂，于是看了<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/">这篇</a>。第二个方法真的很绝，就是想不到。</p><ol><li>哈希表法</li></ol><p>在哈希表中存储旧结点和新节点的键值对，随后遍历map，再更新新节点的指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">    map.put(temp, <span class="keyword">new</span> Node(temp.val));</span><br><span class="line">    temp = temp.next;</span><br><span class="line">&#125; </span><br><span class="line">temp = head;</span><br><span class="line"><span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    map.get(temp).next = map.get(temp.next);</span><br><span class="line">    map.get(temp).random = map.get(temp.random);</span><br><span class="line">    temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map.get(head);</span><br></pre></td></tr></table></figure><ol start="2"><li>拼接法</li></ol><p>将旧链表与新链表的每个结点都拼接起来，随后遍历链表构建random，再拆分新旧链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">Node cur = head;</span><br><span class="line"><span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node tmp = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">    tmp.next = cur.next;</span><br><span class="line">    cur.next = tmp;</span><br><span class="line">    cur = tmp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.random != <span class="keyword">null</span>)</span><br><span class="line">        cur.next.random = cur.random.next;</span><br><span class="line">    cur = cur.next.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 拆分两链表</span></span><br><span class="line">cur = head.next;</span><br><span class="line">Node pre = head, res = head.next;</span><br><span class="line"><span class="keyword">while</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    pre.next = pre.next.next;</span><br><span class="line">    cur.next = cur.next.next;</span><br><span class="line">    pre = pre.next;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">pre.next = <span class="keyword">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line"><span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（一）</title>
      <link href="/2022/01/11/220110-2/"/>
      <url>/2022/01/11/220110-2/</url>
      
        <content type="html"><![CDATA[<h4 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">09. 用两个栈实现队列</a></h4><blockquote><p>难度：简单</p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p></blockquote><p>这个示例给的，让我有点摸不着头脑…</p><p>看了评论区大概懂了题目意思。其实就是两个栈实现队列，删除失败返回-1。</p><p>栈（FILO）先进后出，队列（FIFO）先进先出。</p><p>用两个栈实现队列，一个栈负责插入，另一个栈负责删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//stack1负责队尾插入，直接push即可</span></span><br><span class="line">        stack1.push(value); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*stack2负责队头删除。由于栈的特性,</span></span><br><span class="line"><span class="comment">        要将stack1中的数据倒入stack2中,</span></span><br><span class="line"><span class="comment">        以达到队头元素在stack栈顶的目的，以便pop*/</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = stack1.pop();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但运行速度不尽人意。看到评论区有人解释，Stack继承Vector接口，维护了一个Object[]数组。可以改用LinkedList以提高运行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方题解是这么写的，虽然采用的数据结构是双端队列，但操作受限，也算是栈吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack1;</span><br><span class="line">Deque&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    stack2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">30. 包含min函数的栈</a></h4><blockquote><p>难度简单</p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//stack2为辅助栈，要保持栈顶元素为当前stack1中的最小元素</span></span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x); <span class="comment">//压入stack1</span></span><br><span class="line">        <span class="comment">//在stack2为空、stack2栈顶比当前元素大的情况下</span></span><br><span class="line">        <span class="comment">//压入stack2</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.empty() || stack2.peek()&gt;=x)&#123;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = stack1.pop();</span><br><span class="line">        <span class="comment">//为了维护stack2的特性，故也需要pop</span></span><br><span class="line">        <span class="keyword">if</span>(temp == stack2.peek())&#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次提交时忘了维护stack2，导致用例测试失败。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/01/10/220110-1/"/>
      <url>/2022/01/10/220110-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><br><h2 id="一、网络与因特网"><a href="#一、网络与因特网" class="headerlink" title="一、网络与因特网"></a>一、网络与因特网</h2><h3 id="两种交换"><a href="#两种交换" class="headerlink" title="两种交换"></a>两种交换</h3><p>通过网络链路和交换机移动数据两种方法：分组交换、电路交换。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>多数分组交换机在链路输入端采用<strong>存储转发传输</strong>，是指交换机在向输出链路传输分组第一个比特时，必须接收到该分组的全体。在下图中（忽略传播时延），<em>L</em>表示分组长度，<em>R</em>表示链路传输速率。</p><p>在L/R秒，分组交换机刚好接收到全部分组，2L/R秒，分组全部到达目的地。如不采用存储转发传输，总时延为L/R。类似地，如果有三个分组，总时延将为4L/R。</p><blockquote><p>由N条速率均为R的链路组成的路径（之间有N-1台交换机）：<code>d(时延)=NL/R</code></p><p>P个分组经过N条链路序列的时延：<code>d(时延)=(P+N-1)L/R</code></p></blockquote><pre class="mermaid">graph LR;A[源]-->|分组1|B(分组交换机)B-->C[目的地]</pre><p>交换机有多个链路与之相连，对于每个链路，交换机都有一个输出缓存来存储准备发向那条链路的分组。当到达的分组需要被传输到一个正在处理分组的链路时，就会被放在输出缓存中等待传输，这就是<strong>排队时延</strong>。它是变化的，取决于网络堵程度。当缓存被存满时，就会出现<strong>分组丢失（丢包）</strong>，到达分组/正在等待分组之一就会被丢弃。</p><p>路由器用<strong>转发表</strong>来确定转发链路（映射目的地址）。</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>电路交换网络需要为端系统通信预留资源（电路），可通过频分复用（FDM）和时分复用（TDM）实现。FDM中，链路频谱由连接共享，每条连接专用一个频段。TDM中，时间被划分为固定区间的帧，每帧又被划分为固定数量的时隙，每个连接专用一个时隙用以传输数据。</p><h4 id="分组交换与电路交换对比"><a href="#分组交换与电路交换对比" class="headerlink" title="分组交换与电路交换对比"></a>分组交换与电路交换对比</h4><p>分组交换提供了更好的带宽共享，比电路交换更简单，更有效，实现成本更低。但不适合实时服务（端到端时延不可预测）。电路交换有速率保证，但存在静默期，会造成资源浪费，建立连接较为复杂。但总体来说，分组交换性能要优于电路交换。</p><br><h3 id="分组交换网中的时延"><a href="#分组交换网中的时延" class="headerlink" title="分组交换网中的时延"></a>分组交换网中的时延</h3><p>时延中最为重要的有处理时延、排队时延、传输时延、传播时延，总体累加起来就是<strong>结点总时延</strong>。</p><pre class="mermaid">graph LR;A[源A]-->B(路由器A)D[源B]-->BB-->C(路由器B)</pre><p>分组从上游结点到达A时，A检查分组首部以决定分组的出链路，并将分组导向该出链路。当且仅当该链路没有传输且A的输出缓存（等待队列）中没有别的分组排在该分组之前，该分组才能被从这条链路上传输。否则，需要参与排队。</p><ol><li>处理时延：检查分组首部，导向出链路是处理时延的一部分，还包括检查比特级别的错误所需的时间。</li><li>排队时延：在队列中等待传输的时间，取决于在它之前等待的分组数量。</li><li>传输时延：L/R就是传输时延。表示将分组比特推向链路所需的时间。</li><li>传播时延：从链路起点到路由器B的时间。<code>t=d/s </code>d表示距离，s表示链路传播速率。</li></ol><blockquote><p>传输时延和传播时延很容易混淆。《计算机网络 自顶向下的方法》中用了高速公路收费站的例子来说明。</p><p>将收费站视作路由器，两个收费站之间的公路视作链路，汽车视作比特。</p><p>传输时延就是汽车从进收费站到出收费站所花费的时间，传播时延是汽车从一个收费站离开到进入另一个收费站所需的时间。</p></blockquote><p>对于总时延来说，不同部分时延起的作用，在不同情况下可能会发生很大的变化。</p><br><h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><p>到达的分组发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失。丢失的分组将基于端到端的原则重传，确保所有的数据都被传送到目的地。</p><p>分组丢失的份额随着流量强度增加而增加，当流量强度持续大于1时，就将出现丢包现象。</p><br><h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><blockquote><p>前面一直在讨论结点时延，即单台路由器上的时延。假定此时源主机和目的主机之间有N-1台路由器，网络无拥塞。每台路由器上和源主机上的处理时延d<sub>proc</sub>，每台路由器和源主机的输出速率是<em>R</em> bps，每条链路的传播时延是d<sub>prop</sub>。d<sub>trans</sub>=L/R为传输时延。</p></blockquote><p>结点时延累加起来就得到了端到端时延d<sub>end-end</sub>=N(d<sub>proc</sub>+d<sub>trans</sub>+d<sub>prop</sub>)</p><br><h3 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h3><p>网络设计者以<strong>分层</strong>的方式组织协议以及实现这些协议的网络硬件和软件，每个协议属于这些层次之一，每层通过在该层执行某些动作或直接使用下层的服务来提供服务。</p><blockquote><p>分层的体系机构本身具有结构化和概念化的特点（在我看来类似于解耦，低耦合，高聚合）。对于每一层内部可以变动，只要其提供的供上层使用的服务保持不变，并使用来自下层的相同服务，就不会影响系统其他组件。</p></blockquote><p>协议层能够用软件、硬件或二者的结合来实现。HTTP、SMTP这样的应用层几乎总是在端系统中用软件实现的，对运输层也是如此。物理层和数据链路层通常实现在与给定链路相联系的网络接口卡中。网络层经常是硬件和软件实现的混合体。</p><p>各层的所有协议被称作<strong>协议栈</strong>。</p><h4 id="因特网协议栈"><a href="#因特网协议栈" class="headerlink" title="因特网协议栈"></a>因特网协议栈</h4><p>自顶向下是应用层、运输层、网络层、链路层、物理层。</p><p><b><font color=DeepSkyBlue>应用层</font></b>：是网络应用程序和他们的应用层协议留存的地方。协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，被称为报文。</p><p><b><font color=DeepSkyBlue>运输层</font></b>：在应用程序端点中传送应用层报文。有两个运输层协议TCP和UDP。运输层分组称为报文段。</p><blockquote><p>TCP：提供保证传递，拥塞控制，流量控制</p><p>UDP：无以上保证，不提供不必要服务，提供无连接服务</p></blockquote><p><b><font color=DeepSkyBlue>网络层</font></b>：分组被称为数据报，网络层负责将它从一台主机移动到另一台主机。运输层协议像网络层递交运输层报文段和目的地址。网络层包括IP协议。 </p><p><b><font color=DeepSkyBlue>链路层</font></b>：网络层依靠链路层的服务将分组从一个结点移动到路径上的下一个节点，其中的服务取决于该链路的特定链路层协议。链路层分组被称为帧。</p><p><b><font color=DeepSkyBlue>物理层</font></b>：将帧中的一个一个比特将一个节点移动到下一个结点。每种场合中，跨越链路移动一个比特是以不同的方式进行的。</p><h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><p>ISO提出网络应组织为大约7层，包括应用层，表示层，会话层，运输层，网络层，数据链路层，物理层。</p><p>表示层是使通信的应用程序能够解释交换数据的含义，包括数据压缩、数据加密和数据描述。</p><p>会话层提供了数据交换定界和同步功能，包括建立检查点和恢复方案的方法。</p><p>而在因特网协议栈中，这两层的功能可以由应用程序开发者自行构建。</p><br><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>每一层，每一个分组据有两种类型的字段：首部字段和有效载荷字段。有效载荷字段通常来自上一层分组。</p><h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><h3 id="网络应用程序体系"><a href="#网络应用程序体系" class="headerlink" title="网络应用程序体系"></a>网络应用程序体系</h3><p>分为客户-服务器体系结构或P2P（对等）体系结构</p><blockquote><p>在给定的一堆进程中的通信会话中，  发起请求的是<strong>客户</strong>，等待联系的是<strong>服务器</strong>。</p></blockquote><p>进程中通过套接字交换报文。进程可类比一座房子，而套接字可以类比于门，报文先出门后进房。</p><br><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><blockquote><p>应用层协议只是网络应用的一部分。</p></blockquote><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>Web的应用层协议是HTTP（超文本传输协议），使用TCP作为传输协议，这意味着客户进程的每个HTTP请求报文最终都能完整到达服务器，相反，服务器的每个HTTP响应报文最终都能完整到达客户。HTTP默认持续连接，所有的请求和响应经相同的TCP连接发送。HTTP服务器并不保存客户的任何信息，是个<b>无状态协议</b>。</p><blockquote><p>非持续连接：每次只传输一个请求报文和响应报文，随后中断。</p><p>持续连接：服务器发送响应后保持TCP连接打开，相同客户与服务器之间的后续请求和响应由相同连接传送。</p><p>对比两者，非持续连接必须每次都建立和维护一个新的TCP连接，每个对象要经受两个RTT的时延（创建TCP连接+请求发送对象）。</p></blockquote><h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h5><ol><li>请求报文</li></ol><p>这是用谷歌浏览器获取到的请求baidu.com时的报文。</p><p>第一行叫做请求行，后面行都叫做首部行，首部行后时实体体，使用GET时实体体为空，POST才使用</p><p>请求行包括三个字段：请求方法、URL字段和HTTP版本字段。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br></pre></td></tr></table></figure><ol start="2"><li>响应报文</li></ol><p>第一行是初始状态行，版本、状态码和状态对象，有6个首部行，随后是实体体。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Thu, 13 Jan 2022 04:48:01 GMT</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">Last-Modified: Tue, 11 Jan 2022 02:32:39 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure><p>站点大多采用Cookie，用一个唯一识别码跟踪用户活动。</p><h4 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h4><p>FTP采用TCP进行连接，但与HTTP不同的是，它需要两个并行的TCP链接来传输文件，一个控制连接，服务器打开21端口等待与客户连接，等待命令传送，随后传回回应；一个数据连接，用来传送数据。每次文件传输都需要建立一个新的数据连接。FTP需要在会话过程中保持用户的状态。</p><h4 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h4><p>电子邮件系统包含三部分，用户代理、邮件服务器和邮件协议，通过25端口活动。</p><p>邮件协议分为传输协议和访问协议。</p><p><img data-src="/../../images/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE" alt="image-20220113133804622"></p><h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p><img data-src="/../../images/SMTP" alt="image-20220113134031226"></p><p>SMTP只能发送ASCII码。互联网邮件扩充MIME补充了这个缺点，增加邮件主体结构。</p><h5 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h5><p>当建立了一个通过110端口上的TCP连接时，POP3开始工作。POP3对邮件有“下载删除”，“下载保留”两种处理方式。</p><h5 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h5><p>IMAP将报文与文件夹相联系，收件人可以随意移动文件夹，还可以允许用户查询邮件，允许用户代理读取报文组件。</p><br><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS是一个在因特网上实现分布式数据库的精彩范例。 组织层次大致如图所示。</p><pre class="mermaid">graph TD;A[根DNS服务器]-->B[TLD服务器]A-->C[TLD服务器]A-->D[TLD服务器]B-->E[权威服务器]C-->F[权威服务器]D-->G[权威服务器]D-->H[权威服务器]</pre><br><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>例如文件分发，迅雷也是基于此。边下载边上传。</p><h2 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h2><p>运输层为运行在不同主机上的应用进程提供逻辑通信，运输层协议是在端系统中实现的，因特网有两种协议，即TCP和UDP。</p><br/><h3 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h3><p>多路分解：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p><p>多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装首部信息（用于以后分解）生成报文段，随后将报文段传递到网络层，这些工作成为多路分解。</p><blockquote><p>多路复用的要求：</p><ul><li>套接字有唯一标识符；</li><li>每个报文段有特殊字段来指示该报文段所交付到的套接字；</li></ul></blockquote><p>UDP套接字由一个二元组来全面标识，包含目的IP地址和目的端口号。</p><p>TCP套接字由一个四元组来标识，包含源IP地址，源端口号，目的IP地址，目的端口号。</p><br/><h3 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h3><ul><li>UDP（用户数据报协议）为调用它的应用程序提供了一种不可靠、无连接的服务，尽最大可能交付，没有拥塞控制和流量控制。</li><li>TCP（传输控制协议）为调用它的应用程序提供了一种可靠、面向连接的服务，提供可靠交付，有拥塞控制和流量控制。</li></ul><p>适用UDP的原因：关于何时、发送什么数据的应用层控制更为精细；无需连接建立、无连接状态、分组首部开销小。</p><br/><h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p>首部仅有4个字段，每个字段由2个字节组成。12 字节的伪首部是为了计算检验和临时添加的。</p><p><img data-src="/../../images/d4c3a4a1-0846-46ec-9cc3-eaddfca71254-1642406686409-1642406689150.jpg" alt="img"></p><p>检验和是为了提供差错检测功能，用于确定报文从源到目的地移动时，其中比特是否发生了变化，但UDP对差错恢复无能为力。</p><br/><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><blockquote><p>在研究TCP如何实现数据可靠传输前，作者一步步研究了三种rdt。</p></blockquote><h4 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h4><p>底层信道完全可靠的情况下，无需担心产生差错。</p><h4 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h4><p>再靠近实际一点，分组中的比特可能受损。采用肯定确认和否定确认这样的重传机制的协议被称为自动重传请求。此外还需要三种协议功能来处理比特受损情况。</p><ul><li>差错检测。能使得接收方检测到何时出现比特差错。</li><li>接收方反馈。例如肯定确认（ACK）和否定确认（NAK）。</li><li>重传。接收方收到有差错的分组时，发送方将重传该分组文。</li></ul><h4 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h4><p>但对于2.0来说，当ACK/NAK分组受损时，发送方不知接收方是否正确接收了上一块发送的数据。</p><ul><li>增加足够的检验和比特。发送方不仅可以检测差错，还可以恢复差错。</li><li>引入冗余分组。当ACK/NAK模糊不清时，发送方重传当前数据分组，但对于接收方来说，无法获知收到的分组是重传还是新分组。</li></ul><p><b><font color=brown>一个简单方法，向数据分组中增加“序号”新字段，接收方只需检查序号来判断是否为重传。</font></b></p><h4 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h4><p>在2.1中，当收到失序分组，接收方发送ACK；当收到受损分组，接收方发送一个NAK。但发送上一个分组的ACK也能达到同样效果，则2.2是一个有比特差错信道上实现的一个无NAK的可靠数据传输协议。</p><h4 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h4><p>对于丢包问题，引入了冗余数据分组，为了实现基于时间的重传机制，设定了倒计数定时器。</p><p>发送方能做到每次发送分组时启动定时取，能相应定时器中断，终止定时器。</p><p><em>因为分组序号在01间交替，rdt3.0也被称为比特交替协议</em></p><h4 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h4><p>rdt3.0性能问题的核心在于它是一个停等协议，对于信道的利用率不高。而流水线则不用停等方式运行，允许发送方发送多个分组而无需等待确认。随之而来，必须增加序号范围、两端必须能够缓存多个分组、 所需序号的范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</p><p>差错处理有两种，回退N步（GBN）和选择重传（SR）</p><p><b>GBN</b>：允许发送方发送多个分组而无需等待确认，但流水线中未确认的分组数不能超过N。</p><p><img data-src="/../../images/image-20220117215928936.png" alt="image-20220117215928936"></p><p>[0，base-1]对应发送已被确认的分组，[base，nextseqnum-1]对应已发送未确认分组，[nextseqnum，base+N-1]对应能立即被发送的分组，大于等于base+N的序号无法使用，直至流水线中未被确认的分组被确认。其中N被称为窗口长度，GBN协议也被称为滑动窗口协议。</p><p>发送方也必须响应三类事件</p><ul><li>上层调用：检查窗口是否满了，若是未满，则产生一个分组将其发送。</li><li>收到一个ACK：采取累积确认</li><li>超时事件：会重发所有已发送但未被确认的分组。如果收到一个ACK，定时器重新启动；若没有未被确认的分组，该定时器被终止。</li></ul><p>接收方向发送方发送的是带有当前被成功接收分组序号的ACK（必须为按序交付），其他情况，接收方丢弃该分组，为最近按序接受的分组重新发送ACK。</p><p><b>SR</b>：发送方仅重传它怀疑在接收方出错的分组，避免不必要重传。</p><p><img data-src="/../../images/image-20220117221540147.png" alt="image-20220117221540147"></p><p>SR 发送方：</p><ul><li>从上层接收数据： 检查下一个可用于该分组的序号，若在发送方的窗口内，则将数据打包发送。</li><li>超时： 定时器再次用来防止丢失分组。但是现在每个分组必须得有单独的定时器。</li><li>收到 ACK：倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且该序号落在窗口内的未发送分组，则发送这些分组。</li></ul><p>SR 接收方：</p><ul><li>序号在 [rcv_base, rcv_base + N -1] 内的分组被正确接收：在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组及以前缓存的序号连续的分组交付给上层。</li><li>序号在 [rcv_base - N, rcv_base - 1] 内的分组被正确接收： 产生一个 ACK，即使该分组是接收方以前已确认过的分组。因为视图不一致。</li><li>其他情况：忽略该分组。</li></ul><p>接收方将确认一个正确接收的分组而不管其是否按序；失序的分组被缓存，直到形成连续数据后将其提交给上层；值得注意的是，如果接收方收到了已经确认的分组，则说明确认ACK丢失，或者时延太长，接收方和发送方沟通不及时；这也表明了关于那些分组到位了，那些分组还没到位，接收方和发送方有着不一样的视图。</p><p>另外还需要注意的是，序号的重用问题，如果在分组中序号字段的位数为k，那么最大的序号为2^k-1，所以有可能不同分组同时占用一个序号，为了避免这种情况，需要做的是控制分组的生命周期。窗口长度必须小于或等于序号空间大小的一半。</p><p><img data-src="/../../images/image-20220118100642788.png" alt="image-20220118100642788"></p><br><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="拥塞网络的代价"><a href="#拥塞网络的代价" class="headerlink" title="拥塞网络的代价"></a>拥塞网络的代价</h4><ul><li>当分组的到达速率接近链路容量，分组经过巨大的排队时延。</li><li>发送方必须执行重传以补偿因为缓存溢出而丢弃的分组。</li><li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。 </li><li>一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费。</li></ul><h4 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h4><ul><li>端到端拥塞控制：网络层没有为运输层拥塞控制提供显式支持，TCP必须通过端对端的方法解决拥塞控制。报文段的丢失被认为时网络拥塞的一个迹象。</li><li>网络辅助的拥塞控制：网络层向发送方提供关于网络中拥塞状态的显式反馈信息。采用拥塞分组、路由器标记或更新从发送方流向接收方的分组中的每个字段来指示拥塞的产生。</li></ul><br><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img data-src="/../../images/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img"></p><ul><li>源端口号和目的端口号，被用于多路复用/分解来自或送到上层应用的数据。</li><li>32比特的序号字段：该报文段首字节的字节流编号。</li></ul><blockquote><p>假定数据流由一个500000字节的文字组成，MSS（最大报文段长度）为1000字节，数据首字节编号为0。则被划分为500个报文段。第一个报文段序号为1，第二个为1000，第三个为2000。</p></blockquote><ul><li>32比特的确认号：期望收到的下一个报文段的序号。</li></ul><blockquote><p>如果A已经收到来自B的编号为0~535的所有字节，同时假设他准备发送一个报文段给B，在等到536及以后的所有字节，所以A-B的报文确认字段号填上536。</p></blockquote><ul><li>16比特的接收窗口字段，用于流量控制，填入接收方愿意接受的字节数量。</li><li>4比特的首部长度（数据偏移）字段：指定了以32比特的字为单位的TCP首部长度。</li><li>6比特的标志字段</li></ul><blockquote><p>ACK比特：确认字段的值是有效的。</p><p>SYN比特：连接建立时同步序号。</p><p>FIN比特：释放连接的信号。</p></blockquote><p>TCP采取超时/重传机制处理文报丢失。TCP仅为传输一次的报文段测量SampleRTT，然后用<code>EstimatedRTT = (1-a)*EstimatedRTT + a*SampleRTT</code>更新EstimatedRTT。使用<code>DevRTT = (1-b)*DevRTT + b*|SampleRTT-EstimatedRTT|</code>计算RTT偏差。而超时间隔<code>TimeoutInterval = EstimatedRTT + 4*DevRTT</code>。</p><h4 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h4><p>TCP在IP尽力而为的服务上创建了一种可靠数据传输服务。</p><p>TCP发送方有3个与发送和重传有关的主要事件：</p><ul><li>从上层接收到数据：封装数据到报文段，交给IP。启动定时器，过期间隔是<code>TimeoutInterval</code>。        </li><li>定时器超时：重传超时的报文段，随后TCP重启定时器。</li><li>收到ACK：根据y与SendBase的关系，采取累计确认/重启定时器。</li></ul><p>超时间隔加倍：TCP在重传具有最小序号的还未被确认的报文段，只是每次TCP重传是都会将下一次的超时间隔设为先前值的2倍，而不是用EstimatedRTT和DevRTT推算出来的值。</p><p>快速重传：利用冗余ACK（当TCP收到一个序号大于下一个所期望的按需的报文段，检测到数据有间隔，意味着有报文段丢失，接收方对已接受到的最后一个按序字节数据发送ACK），一旦受到三个冗余ACK，TCP就执行快速重传，在定时器过期之前重传丢失的报文段。</p><p>TCP的差错回复机制采取选择确认和选择重传机制，最好被分类为GBN和SR协议的混合体。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方通过维护一个称为接收窗口的变量来提供流量控制，通过该窗口，发送方可以获知接收方还有多少可用的缓存空间。 </p><br/><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p><img data-src="/../../images/image-20220117171509715.png" alt="image-20220117171509715"></p><ul><li>服务器端处于LISTEN（监听）状态；</li><li>客户端向服务器端发送一个特殊TCP报文段，该文段中不包含应用层数据。SYN=1，会随便选择一个初始序号client_isn（seq=client_isn）；</li><li>服务器端接到请求报文，为该TCP连接分配缓存和变量，并发送一个确认报文。SYN=1，ACK=1，确认号为client_isn+1（ack=client_isn+1），选择一个初始序号server_isn（seq=server_isn）【该报文被称为SYNACK报文段】；</li><li>接到SYNACK报文后，客户也要给该连接分配缓存和变量，并向主机发送另一个报文段。该报文段可以携带数据。SYN=0，seq=clinet_isn+1，ack=server_isn+1。【之后的报文中，SYN都被置为0】</li></ul><p><b>为什么是三次握手，而不是两次握手/四次握手？</b></p><p>答：两次握手：客户发送请求、seq=client_isn；服务器确认客户发来的seq，自己的seq=server_isn。这样只对客户的起始序列号达成同步，对服务器的起始序列号没有同步，无法达成可靠连接。</p><p>四次握手：客户发送请求、seq=client_isn；服务器确认客户seq，并发送ack=client_isn+1；服务器发送seq=server_isn；客户端确认服务器seq，发送ack=server_isn+1。其中23步可以合并，提高连接效率和速度。</p><br/><h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><p><img data-src="/../../images/image-20220117211834313.png" alt="image-20220117211834313"></p><ul><li>客户端进程发出一个关闭连接命令，FIN=1；</li><li>服务器收到后发出ACK报文段；</li><li>服务器发出自己的终止报文，FIN=1；</li><li>客户端进行确认，连接被释放。</li></ul><br/><h4 id="客户端和服务端TCP经历的各种状态"><a href="#客户端和服务端TCP经历的各种状态" class="headerlink" title="客户端和服务端TCP经历的各种状态"></a>客户端和服务端TCP经历的各种状态</h4><p><img data-src="/../../images/image-20220117212159479.png" alt="image-20220117212159479"></p><p><img data-src="/../../images/image-20220117212228160.png" alt="image-20220117212228160"></p><h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>TCP让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。丢包事件被定义为超时/收到来自接收方的3个冗余ACK。</p><p>TCP拥塞控制算法：</p><ul><li>慢启动模式</li></ul><blockquote><p>当一条TCP连接开始时，cwnd（拥塞窗口）通常初始置为一个MSS的较小值，在慢启动状态，每经过一个RTT，报文被确认后，发送速率都翻番。例如：开始增加为2个MSS，确认后被增加为4MSS。</p><p>何时结束指数级增长呢？ssthresh是慢启动阈值。</p><ol><li>超时，cwnd设为1，重新开始慢启动，ssthresh设为cwnd的一半。</li><li>当检测到ssthresh为cwnd的一半，结束慢启动并将TCP转移到拥塞避免模式，更为谨慎地增加cwnd。</li><li>若检测到3个冗余ACK，TCP执行一次快速重传并进入快速恢复状态。</li></ol></blockquote><ul><li>拥塞避免模式</li></ul><blockquote><p>TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS字节。</p><p>何时结束拥塞避免的线性增长？</p><ol><li>超时，cwnd被设置为1个MSS</li><li>丢包，ssthresh被更新为cwnd的一半。</li><li>3个冗余ACK，ssthresh记录为cwnd的一半，接下来进入快速恢复状态。</li></ol></blockquote><ul><li>快速恢复模式（推荐的而非必需的构件）</li></ul><blockquote><p>对于引起TCP进入快速恢复状态的缺失报文段，对于收到的每个冗余ACK，cwnd增加一个MSS。</p><ol><li>对丢失报文段的一个ACK到达，TCP在降低cwnd后进入拥塞避免模式</li><li>出现超时，cwnd被设置为1个MSS，迁移到慢启动状态</li><li>丢包，cwnd被设置为1个MSS，ssthresh的值设置为cwnd的一半。</li></ol></blockquote><p>TCP拥塞控制被称为<strong>加性增、乘性减</strong>。</p><br><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h3 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h3><p>网络层的作用即将分组从一台发送主机移动到一台接受主机，故必须具有两大功能：</p><ul><li>转发：一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。</li><li>路由选择：分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。路径的算法被称为路由选择算法。</li></ul><blockquote><p>每个路由器具有一张转发表，路由器通过检查到达分组首部字段的值来转发分组（可能是目的地址或该分组所属连接的指示，取决于网络层协议），利用该值在该路由器转发表中索引查询。查询到的值指出了该分组将被转发的路由器的输出链路接口。</p><p>路由选择算法决定了插入路由器的转发表中的值，由路由器接受路由选择协议报文，用于配置转发表。</p></blockquote><p>在某些计算机网络中，还会有第三种网络功能，连接建立。允许发送方和接收方建立所需的状态信息，要求从源到目的地沿着所选择的路径彼此握手，以便在给定源到目的地连接中的网络层数据分组能够开始流动之前建立起状态。</p><br/><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><p>在发送主机中，当运输层向网络层传递一个分组时，能由网络层提供的特定服务包括：</p><ul><li>确保交付。该服务确保分组将最终到达目的地。</li><li>具有时延上界的确保交付。</li></ul><p>能够为给定的源和目的地之间的分组流提供以下服务：</p><ul><li>有序分组交付。确保分组以它们发送的顺序到达目的地。</li><li>确保最小带宽。</li><li>确保最大时延抖动。</li><li>安全性服务。机密性、数据完整性和源鉴别服务。</li></ul><br/><h3 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h3><p>这些服务是由网络层向运输层提供的主机到主机的服务。仅在网络层提供连接服务的计算机网络称为虚电路网络，提供无连接服务的称为数据报网络。</p><p>一条虚电路的组成：源和目的主机之间的路径，VC号（沿着该路径的每一条链路的一个号码），沿着该路径的每台路由器中的转发表表项。每条链路上的VC号不同，是因为逐链路代替该号码减少了在分组首部中VC字段的长度，也简化了虚电路的建立。</p><p>只要创建一条新的虚电路，转发表就增加一个新表项；只要终止 一条虚电路，沿着该路径每个表中的相应项将被删除。路由器也必须为连接维持连接状态信息。</p><p>在数据报网络中，每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，再将分组推进网络中。这种发送可能是无序到达的。</p><br/><h3 id="转发和编址"><a href="#转发和编址" class="headerlink" title="转发和编址"></a>转发和编址</h3><p>网络层有三个主要组件，即IP协议、路由选择部分和报告数据包中的差错和对某些网络层信息请求进行响应的设施</p><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>IPv4编址为子网分配一个地址223.1.1.0/24，其中/24的记法有时称为子网掩码，意味着32比特中最左侧的24比特定义了子网地址。因特网采用无类别域间路由选择（CIDR）进行地址分配。当一台主机发出一个目的地址为255.255.255.255的数据包时，该报文会交付给同一个网络中的所有主机。</p><p>一个组织如何为设备获取地址块？</p><ul><li>从一个ISP获取一组地址</li></ul><p>一个设备如何从某组织的地址块中分配到一个地址？</p><p>采用动态主机配置协议（DHCP）来完成，允许主机自动获取一个IP地址，而通过配置DHCP，使得某给定主机每次与网络连接时能得到一个相同的IP地址，或某主机被分配到一个临时的IP地址。DHCP也被称为即插即用协议，能将主机连接进一个网络的自动能力。</p><h4 id="因特网控制报文协议ICMP"><a href="#因特网控制报文协议ICMP" class="headerlink" title="因特网控制报文协议ICMP"></a>因特网控制报文协议ICMP</h4><p>ICMP位于IP之上，但被封装在IP内。报文包括一个类型字段和一个编码字段。</p><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>将IP地址长度由32比特增加到128比特，并加入了一种称为任播地址的新型地址，可以将数据报交付给一组主机中的任意一个，40字节的定长首部，不允许在中间路由器上进行分片和重新组装，去掉首部检验和字段。</p><br/><h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>算法广义分类：</p><ul><li>全局式（LS链路状态算法）/分散式（DV距离向量算法）</li><li>静态/动态路由选择算法</li><li>负载敏感/负载迟钝算法</li></ul><h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><ul><li><p>内部网关协议RIP</p><p>RIP（路由选择信息协议）是一种距离向量协议。距离是指跳数，直接相连的路由器跳数为1，一条链路最大费用被限制为15。在邻居家通过使用一种RIP响应报文来交换，大概每30s相互交换一次。响应报文中包含一个该AS内的多达25个目的子网的列表</p></li><li><p>内部网关协议OSPF</p><p>OSPF（开放最短路优先）其核心为一个使用洪泛链路状态信息的链路状态协议和一个Dijkstra最短路径算法。</p></li><li><p>边界网关协议BGP</p><p>它为跨越多个AS的源和目的队之间确定路径提供了途径。BGP为每个AS提供了以下工作的手段：从相邻AS处获得子网可达性信息 ，向本AS内部的所有路由器传播这些可达性信息，基于可达性信息和AS策略决定到达子网的“好”路由。</p><br></li></ul><h2 id="五、链路层"><a href="#五、链路层" class="headerlink" title="五、链路层"></a>五、链路层</h2><p>链路层的主体在网络适配器中实现，提供的服务包括：</p><ul><li>成帧：在网络层数据报经链路传送之前，几乎所有的协议都要将其封装起来。</li><li>链路接入</li><li>可靠交付</li><li>差错检测和纠正</li></ul><h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><ul><li><p>时分多路复用（TDM）所有主机在不同的时间占用相同的频率带宽资源。</p></li><li><p>频分多路复用（FDM）所有主机在相同的时间占用不同的频率带宽资源。</p></li><li><p>码分多址（CDMA）为每个结点分配一种不同的编码，使用这个唯一编码对数据进行编码。</p></li></ul><h4 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h4><ul><li>时隙ALOHA协议</li><li>载波侦听多路访问（CSMA）协议</li><li>具有碰撞检测的载波侦听多路访问协议（CSMA/CD）</li></ul><h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><ul><li>轮询协议</li><li>令牌传递协议</li></ul><h3 id="链路层寻址"><a href="#链路层寻址" class="headerlink" title="链路层寻址"></a>链路层寻址</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>网络接口具有链路层地址，但交换机并不具有与之相关联的接口的链路层地址。链路层地址也被称为LAN地址、物理地址或MAC地址。适配器地址不同，具有扁平结构。</p><h4 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h4><p>ARP将一个IP地址解析为MAC地址，只为在同一个子网上的主机和路由器接口解析IP地址。</p><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网是一种星形拓扑局域网，在发展中，交换机逐步将集线器替代。以太网帧的负载是一个IP数据报，但也可以承载其他网络层分组，采取<em>类型</em>字段来区别协议格式，CRC可以使得适配器检测帧中是否引入了差错。以太网技术向网络层提供不可靠服务。</p><h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><p>交换机自身对于子网中的主机和路由器是透明的，主机/路由器在传送帧时，并不知道交换机在其中的作用。交换机狮是自学习的，即插即用的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/09/220109/"/>
      <url>/2022/01/09/220109/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础-五"><a href="#Java基础-五" class="headerlink" title="Java基础(五)"></a>Java基础(五)</h1><h2 id="一、组成部分"><a href="#一、组成部分" class="headerlink" title="一、组成部分"></a>一、组成部分</h2><p>答：JVM由Class Loader（类加载器）、Runtime Data Area（运行时数据区域）、Execution Engine（执行引擎）、Native Interface（本地库接口）。</p><p>Class Loader负责加载字节码文件；Runtime Data Area分为Stack（虚拟机栈）、Heap（堆）、Method Area（方法区）、PC Register（程序计数器）、Native Method Stack（本地方法栈），负责加载数据；Execution Engine将Class Loader加载的命令解释给操作系统；Native Interface负责调用本地接口。</p><p>Java虚拟机所管理的内存将会包括以下几个运行时数据区域。</p><p><img data-src="/../../images/jvm.jpg" alt="img"></p><p>PC Register（程序计数器）负责记录正在执行的虚拟机字节码指令的地址（本地方法则为空）</p><p>每个Java方法在执行时会创建一个栈帧存放在Stack（虚拟机栈）内用以存放局部变量表，操作数栈，常量池引用等信息。方法从执行到完成对应着一个栈帧的入栈和出栈。<code>-Xss</code>可以用来指定虚拟机栈的大小。</p><p>Native Method Stack（本地方法栈）与Stack类似，只是本地方法栈中存放本地方法的栈帧。</p><p>Heap（堆）是虚拟机所管理的内存中最大的一块，被所有线程共享，在JVM启动之初就被创建，只存放对象实例。无须连续内存，可以动态增加，增加失败会抛出<code>OutOfMemoryError</code>的异常，<code>-Xms</code>设定初始值，<code>-Xmx</code>设定最大值。</p><p>Method Area（方法区）用已存放被加载的类信息，常量，静态变量，即时编译器等数据，和Heap类似，被所有线程共享，无须连续内存，可以动态增加，增加失败会抛出<code>OutOfMemoryError</code>的异常。为了与Heap区分开，也叫Non-Heap。</p><p>Runtime Constant Pool（运行时常量池）是方法区的一部分，class文件中的常量池会在类加载后放到这个区域。</p><p>Direct Memory（直接内存）并不是虚拟机运行时数据区的一部分，是Java堆之外的，直接向系统申请的内存空间，但也可能导致</p><p><code>OutOfMemoryError</code>。JDK引入NIO后，操作系统内就直接划出了一块直接缓存区可以直接被Java访问，即“零拷贝”，能显著提高性能。 </p><h2 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h2><p>主要针对方法区和堆进行垃圾回收，程序计数器、虚拟机栈和本地方法栈属于线程私有，线程结束后就会消失，因此无需进行垃圾回收。</p><ol><li><p>判断对象是否可回收。</p><ul><li><p>引用计数算法</p><p>当对象增加一个引用时，计数器加一，失效时，计数器减一。当计数器变为0时，对象可被回收。当两个对象出现循环引用时，该方法失效，故JVM不采取该方法。</p></li><li><p>可达性分析</p><p>该方法以一系列的GC Roots为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。</p><p>GC Roots一般指：虚拟机栈中局部变量表中引用的对象，本地方法栈中JNI（native方法）引用的对象，方法区中静态属性和常量引用的对象。</p></li></ul></li><li><p>但不可达的对象也不代表着它一定要死亡。死亡对象要经过两次标记。</p><ul><li><p>第一次标记：经过可达性分析，进行筛选后，标记。条件是：此对象是否有必要执行finalize（）方法。</p><p>若被判定为有必要执行finalize方法，这个对象会被放置在一个F-Queue队列中。</p><ul><li>对象没有覆盖finalize方法</li><li>finalize方法已经被虚拟机调用过</li></ul><p>以上两种情况均被视作没有必要执行。</p></li><li><p>第二次标记：GC会对队列中的对象进行二次小规模标记，只要对象与引用链上的任何一个对象建立关联即可被移除出”即将回收“的集合。</p></li></ul></li><li><p>回收方法区</p><p>方法区的垃圾收集效率很低。主要收集废弃常量以及无用的类。</p><p>废弃常量是指没有对象指向且没有被引用的常量池成员，包括类（接口）、方法、字段等</p><p>无用类：必须满足下面三个条件才算是”无用的类“，且不一定会被回收。</p><ul><li>该类的所有的实例都已经被回收（堆中不存在该类的任何实例）</li><li>加载该类的ClassLoader被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li><li><p>垃圾收集算法</p><ul><li><p>标记-清除</p><p>标记阶段，程序会检查每个对象是否存活，若存货，则程序会在对象头部打上标记；清除阶段进行对象回收取消标记位。</p><ul><li>不足：效率低下，会产生大量不连续的内存碎片</li></ul></li><li><p>标记-整理</p><p>让所有存活的对象向一端移动，直接清理掉端边界以外的内存。</p><ul><li>不足：要移动大量对象，处理效率低</li><li>不会产生内存碎片</li></ul></li><li><p>复制</p><p>将内存空间平分为两部分，每次只使用一半，一块用完后就将存活的对象复制到另一半，然后将这一半直接清理。</p><ul><li>不足：空间利用率低。</li></ul><p>现在商业虚拟机一般采用这种方法收集新生代。会将空间化为较大的Eden和两块较小的Survivor，每次使用Eden和一块Survivor。HotSpot默认的Eden：Survivor大小比例为8：1。当Survivor空间不够时，需要依赖老年代进行分配担保，存入老年代。</p></li><li><p>分代收集</p><p>将堆分为新生代和老生代。新生代使用复制算法，老生代使用标记-清除/标记-整理</p></li></ul></li><li><p>垃圾收集器</p><ul><li><p>单线程，多线程：垃圾收集器只使用一个线程/使用多个线程</p></li><li><p>串行并行：串行指垃圾收集器和用户程序交替执行，需要停顿用户程序；并行指垃圾收集器和用户程序同时执行。除CMS和G1，其他垃圾收集器都以串行方式执行。</p><p>垃圾收集器关注点是尽可能缩短垃圾收集时，用户线程的停顿时间，而Parallel Scavenge目标是达到一个可控制的吞吐量。</p></li></ul></li></ol><table><thead><tr><th>序号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Serial收集器（单线程）</td><td>Client环境下默认新生代收集器（复制算法）</td></tr><tr><td>2</td><td>ParNew收集器（Serial的多线程版本）</td><td>Server环境下默认新生代收集器，可与CMS配合（新生代复制算法，老年代标记整理）</td></tr><tr><td>3</td><td>Parallel Scavenge收集器（多线程）</td><td>”吞吐量优先“（新生代复制收集算法）</td></tr><tr><td>4</td><td>Serial Old收集器</td><td>Serial老年代版本（新生代复制，老年代标记整理）</td></tr><tr><td>5</td><td>Parallel Old收集器</td><td>Parallel Scavenge老年代版本（标记整理）</td></tr><tr><td>6</td><td>CMS（Concurrent Mark Sweep）</td><td>基于标记清理</td></tr><tr><td>7</td><td>G1收集器</td><td>可以直接回收新生代和老年代（整体上基于标记整理，局部采用复制）</td></tr></tbody></table><ul><li><p>CMS可被划分为四个流程：</p><ul><li>初始标记：标记GC Roots可达的对象，需要暂停用户程序</li><li>并发标记：GC Roots Tracing，无需暂停，可并发完成（耗时最长）</li><li>重新标记：修正上一步过程中用户程序修改后的对象标记，需要暂停用户程序</li><li>并发清理：无需暂停用户程序</li></ul><p>缺点在于：低暂停时间牺牲了吞吐量，无法处理浮动垃圾，只能等到下次GC进行回收。标记-清除算法会造成老年代空间浪费。</p></li><li><p>G1则将堆划分为多个大小相等的独立区域，可以对每个小空间进行单独垃圾回收。每个region都有Remembered Set用以记录该region对象的引用对象所在的Region。可大概划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：修正并发标记过程中因为用户程序而发生改变的对象标记，需要暂停线程，但可以并发执行</li><li>筛选回收：按照回收价值和成本进行排序，按照用户所期望的GC停顿时间来制定回收计划。</li></ul><p>整体按照标记-整理实现收集器，局部基于复制算法实现。停顿也是可预测的。</p></li></ul><ol start="6"><li>Java的四种引用，参看<a href="https://blog.csdn.net/qq_43598179/article/details/122271935?spm=1001.2014.3001.5502">Java基础（一）</a>49</li></ol><h2 id="三、内存分配和回收"><a href="#三、内存分配和回收" class="headerlink" title="三、内存分配和回收"></a>三、内存分配和回收</h2><p>Minor GC：新生代GC，指发生在新生代的垃圾收集动作，由于Java对象大多朝生夕灭，所以Minor GC非常频繁，回收速度也比较快。触发条件较为简单，Eden空间满时，就会触发一次MinorGC。</p><p>Major GC：发生在老年代的GC，至少会伴随一次的Minor GC，速度会比Minor GC慢10倍以上。触发条件较为复杂</p><ul><li>调用System.gc()。但虚拟机不一定真正去执行。</li><li>老年代空间不足。例如下面的2、3。故应当避免创建过大的数组和对象。</li><li>空间分配担保失败。例如下面的5。</li><li>JDK1.7及以前的永久代空间不足。</li><li>Concurrent Mode Failure，CMS GC过程中有对象要放入老年代，而老年代空间不足，会报这个错误，触发Full GC。</li></ul><ol><li><p>对象优先在Eden分配。</p><p>多数情况下，对象在新生代Eden区中分配，当空间不足够时，虚拟机将发起一次Minor GC。</p></li><li><p>大对象直接进入老年代</p><p>大对象：需要大量连续内存空间的Java对象例如数组、字符串，避免Eden、Survivor之间的大量内存复制。</p></li><li><p>长期存活的对象进入老年代</p><p>为每个对象定义了一个对象年龄计数器。如果对象在Eden出生，并经过第一次Minor GC后仍然存活，且能被Survivor容纳，将被移至Survivor中，且年龄被设为1。在Survivor区中每熬过一次Minor GC，年龄就增加一岁。直至增加到一定程度（默认15岁）就会被晋升到老年代。阈值可以通过<code>-XX:MaxTenuringThreshold</code>来设置。</p></li><li><p>动态对象年龄判断</p><p>虚拟机并不是永远地要求对象的年龄必须到达阈值才能晋升老年代，如果在Survior空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需达到阈值。</p></li><li><p>空间分配担保</p><p>在Minor GC前，会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则Minor GC是安全的。如果不成立，虚拟机会查看HandlePromotionFailure的值是否允许担保失败。如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则冒险进行Minor GC，若小于，进行Full GC。</p></li></ol><h2 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h2><p>JVM将描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以直接被虚拟机使用的Java类型，这就是虚拟机的类加载机制。类型的加载、连接和初始化都是在程序运行期间完成的，虽然略微增加了性能开销，但为java应用程序提供了高度的灵活性。</p><pre class="mermaid">graph LR;A[加载]-->B[验证]B-->C[准备]C-->D[解析]D-->E[初始化]E-->F[使用]F-->G[卸载]</pre><p>上图：类从被加载到虚拟机内存开始，到卸载出内存为止，整个的生命周期。验证、准/备、解析统称为连接部分。</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><ol><li>加载、验证、准备、初始化和卸载阶段的顺序是确定的。<strong>解析</strong>不一定非按照这个顺序开始，某些情况下它可以在初始化阶段之后再开始，以实现动态绑定。</li><li>Java虚拟机规范中严格规定了<strong>有且仅有</strong>5种情况必须立即对类进行”初始化“。<ul><li>遇到new、getstatic、putstatic、invokestatic时，若类没有进行初始化，则必须先触发它的初始化。</li><li>使用java.lang.reflect包的方法对类进行发射调用时，若类没有进行初始化，则必须先触发它的初始化。</li><li>当初始化一个类时，若它的父类没有进行初始化，则必须先触发父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要触发其初始化。</li></ul></li><li>主动引用：上述五种情况成为主动引用。</li><li>被动引用：除上述五种情况外， 所有引用类的方式都不会触发初始化，成为被动引用。</li></ol><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ol><li>加载阶段（与连接阶段的部分内容是交叉进行的，但开始时间保持着固定的先后顺序），虚拟机要完成下面三件事情：<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul></li><li>验证阶段为了确保Class文件的字节流符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 包括文件格式验证、源数据验证、字节码验证、符号引用验证。</li><li>准备阶段是正式为类变量分配内存并设置类变量初始值的过程，变量所使用的内存都将在方法去进行分配。仅仅只有类变量，不包括实例变量；初始值通常情况下是数据类型的零值。</li><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</li><li>初始化阶段是类加载的最后一步，开始真正执行类中定义的Java程序代码。</li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ol><li><p>两个类相等，需要类本身相等，并使用同一个类加载器进行加载，因为每个类加载器都拥有一个独立的类名称空间。相等包括类的Class对象的equals、isAssignableFrom、isInstance方法的返回结果。</p></li><li><p>双亲委派模型</p><ul><li><p>启动类加载器，采用c++语言实现，是虚拟机自身的一部分</p></li><li><p>所有其他类的加载器：使用Java实现，独立于虚拟机，继承自抽象类java.lang.ClassLoader</p><p>还可以细分为三种：</p><ul><li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li><li>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li></ul><br><p>应用程序是由三种类加载互相配合从而实现类加载，除此之外可以加入自己定义的类加载器。除了顶层的启动类加载器外，其他的类加载器都要有自己的父类加载器，一般通过组合关系实现。</p><p><img data-src="/../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png"></p><p>工作过程：一个类加载器首先将类加载请求委派给父类去完成，只有当父类加载器无法完成是，子类加载器才会尝试自己加载。</p><p>好处在于Java类随着类加载器拥有了一种带有优先级的层次关系。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础知识复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(四)</title>
      <link href="/2022/01/09/220108/"/>
      <url>/2022/01/09/220108/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础（四）"><a href="#Java基础（四）" class="headerlink" title="Java基础（四）"></a>Java基础（四）</h1><h4 id="1-创建线程有哪几种方式？"><a href="#1-创建线程有哪几种方式？" class="headerlink" title="1 创建线程有哪几种方式？"></a>1 创建线程有哪几种方式？</h4><p>答：实现Runnable接口，实现Callable接口，继承Thread类。</p><ol><li><p>创建实现Runnable的类，并实现run方法。创建实现类的实例，将它作为thread的target创建线程，start方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">first</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread1 thread1 = <span class="keyword">new</span> Thread1(<span class="string">&quot;runnable&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(thread1);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(Thread.currentThread() .getName()+<span class="string">&quot;**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;//&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;//&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实现Callable的类，实现call方法（有返回值），创建该类实例。用FutureTask包装对象。用ft作为Thread对象的target创建并启动新线程，get方法可以获得call的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">first</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Thread1());</span><br><span class="line">        <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        System.out.println(ft.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;******&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is a Callable thread&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承Thread，重写run方法，创建该类实例，调用start方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">first</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Thread1 t1 = <span class="keyword">new</span> Thread1(<span class="string">&quot;xindeduixiang&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:now!!!&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-run-和start-有什么区别？"><a href="#2-run-和start-有什么区别？" class="headerlink" title="2 run()和start()有什么区别？"></a>2 run()和start()有什么区别？</h4><p>答：run是线程执行体，代表线程执行需要完成的任务。start用于启动线程。使用start启动线程，run会被当作线程执行体来处理，但直接调用run会被当作普通方法处理。</p><h4 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3 线程的生命周期"></a>3 线程的生命周期</h4><p>答：new–&gt;ready–&gt;running–&gt;blocked–&gt;dead</p><p>new新建线程后，该线程就处于new状态；调用start方法，处于ready状态；执行run方法后，处于running状态；线程中断会处于blocked状态；结束后处于dead状态。<img data-src="/../../images/thread-1.png" alt="img"></p><h4 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4 线程同步"></a>4 线程同步</h4><p>答：synchronized关键字修饰方法、语句块，ReentrantLock、volatile关键字（保证了不同线程对这个变量进行操作时的可见性、禁止进行指令重排序），原子变量。</p><h4 id="5-Java多线程通信"><a href="#5-Java多线程通信" class="headerlink" title="5 Java多线程通信"></a>5 Java多线程通信</h4><p>答：</p><ol><li><p>wait()、notify()、notifyAll()</p><p>适用于线程间采用synchronized确保安全的情况，三个都是Object类中声明的方法。</p></li><li><p>await()、signal()、signalAll()</p><p>适用于线程间采用Lock确保安全的情况</p></li><li><p>BlockingQueue</p></li></ol><h4 id="6-如何实现子线程先执行，主线程再执行"><a href="#6-如何实现子线程先执行，主线程再执行" class="headerlink" title="6 如何实现子线程先执行，主线程再执行"></a>6 如何实现子线程先执行，主线程再执行</h4><p>答：启动子线程后，立刻调用该线程的join方法</p><h4 id="7-synchronized和Lock的区别"><a href="#7-synchronized和Lock的区别" class="headerlink" title="7 synchronized和Lock的区别"></a>7 synchronized和Lock的区别</h4><p>答：</p><ol><li>synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁。</li><li>synchronized可以用在代码块上、方法上；Lock只能写在代码里。</li><li>synchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁<code>lock.unlock()</code>。</li><li>synchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间。</li><li>synchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功。</li><li>synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平/不公平，并可以细分读写锁以提高效率。</li></ol><h4 id="8-乐观锁与悲观锁的区别"><a href="#8-乐观锁与悲观锁的区别" class="headerlink" title="8 乐观锁与悲观锁的区别"></a>8 乐观锁与悲观锁的区别</h4><p>答：乐观锁：觉得别人不会修改数据，因此不会上锁，但会在更新时判断其他线程在这之前有没有对数据进行修改，通常采取<a href="https://www.iteye.com/blog/zl198751-1848575">CAS操作</a>实现。(这篇博客写的非常清晰)</p><p>悲观锁：每次取数据都认为其他线程会修改，所以每次都会加锁，其他线程想要访问数据时，都要阻塞挂起，例如synchronized。</p><h4 id="9-公平锁与非公平锁如何实现"><a href="#9-公平锁与非公平锁如何实现" class="headerlink" title="9 公平锁与非公平锁如何实现"></a>9 公平锁与非公平锁如何实现</h4><p>答：公平锁：即按照线程等待时长来决定锁使用权。公平锁为保证时间上的绝对顺序，需要频繁的上下文切换，非公平锁相比系统开销较小，保证了系统较大的吞吐量。</p><p>synchronized只能是非公平锁，ReentrantLock默认非公平但可实现公平的锁。</p><p>公平锁的实现机制在于每次有线程来抢占锁是，会检查有无等待队列；非公平锁则是随机抢占。</p><h4 id="10-ReentrantLock的实现原理"><a href="#10-ReentrantLock的实现原理" class="headerlink" title="10 ReentrantLock的实现原理"></a>10 ReentrantLock的实现原理</h4><p>答：它的实现基于AQS（AbstractQueuedSynchronizer）。<a href="https://juejin.cn/post/6844903601534418958">AQS</a>内部实现了两个队列，同步队列和条件队列，并提供了一些方法给子类用以重写，而AQS中的模板方法则会调用被重写后的子类方法，负责同步状态的管理、线程排队，等待唤醒…在同步队列中还存在着<a href="https://juejin.cn/post/6844903601538596877#heading-5">独占锁和共享锁</a>。下图为ReentrantLock的结构。<img data-src="/../../images/reentrantlock.png" alt="img"></p><p>ReentrantLock实现了Lock接口，三个内部类，Sync继承于AQS，FairSync和NonFairSync都继承自Sync，分别用来实现公平锁和非公平锁。默认非公平锁。ReentrantLock实现了AQS的独占模式，是个悲观锁。</p><h4 id="11-锁升级"><a href="#11-锁升级" class="headerlink" title="11 锁升级"></a>11 锁升级</h4><p>答：JDK 1.6中，锁共有四种状态：无锁、偏向锁、轻量级锁、重量级锁。锁可以升级但不能降级，目的在于提高获得锁和释放锁的效率。<a href="https://juejin.cn/post/6844903600334831629">可以看该篇的第三章</a>。</p><h4 id="12-如果不使用synchronized和Lock，如何保证线程安全？"><a href="#12-如果不使用synchronized和Lock，如何保证线程安全？" class="headerlink" title="12 如果不使用synchronized和Lock，如何保证线程安全？"></a>12 如果不使用synchronized和Lock，如何保证线程安全？</h4><p>答：volatile关键字、不可变量（如String）、原子变量（util.concurrent.atomic)，本地存储（ThreadLocal类）</p><h4 id="13-介绍一下线程池"><a href="#13-介绍一下线程池" class="headerlink" title="13 介绍一下线程池"></a>13 介绍一下线程池</h4><p>答：它在系统启动之时就创建大量的空闲线程，一旦传入一个Runnable/Callable对象，线程池就会启动一个空闲线程去执行，执行完毕后线程不会dead，会重新进入池中成为空闲状态，等待执行。通过<code>ThreadPoolExecutor</code>类来实现。</p><p>工作流程如下所示：</p><p><img data-src="/../../images/threadpool-2.png" alt="img"></p><p>饱和策略有：丢弃任务并抛出异常、只丢弃任务不抛出异常、抛弃队列的最前面的任务，重复尝试执行、交由调用线程处理。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(三)</title>
      <link href="/2022/01/07/220106/"/>
      <url>/2022/01/07/220106/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础（三）"><a href="#Java基础（三）" class="headerlink" title="Java基础（三）"></a>Java基础（三）</h1><h4 id="1-介绍一下Java中的IO流"><a href="#1-介绍一下Java中的IO流" class="headerlink" title="1 介绍一下Java中的IO流"></a>1 介绍一下Java中的IO流</h4><p>答：IO用以实现数据的输入输出。Java将输入/输出源抽象为流</p><ol><li><p>按功能划分：</p><p>输入流：只能读数据</p><p>输出流：只能写数据</p></li><li><p>按处理单元划分：</p><p>字节流：InputStream、OutputStream作为基类，8位字节</p><p>字符流：Reader、Writer作为基类，16位字符</p></li><li><p>按角色划分：</p><p>节点流：直接从/向特定IO设备读/写数据（低级流）</p><p>处理流：对节点流的连接或封装，简化以及提高效率（高级流）</p></li></ol><h4 id="2-怎么用流打开一个大文件？"><a href="#2-怎么用流打开一个大文件？" class="headerlink" title="2 怎么用流打开一个大文件？"></a>2 怎么用流打开一个大文件？</h4><p>答：分次读取。采取缓冲流；NIO采用内存映射文件处理。</p><h4 id="3-说说NIO的实现原理"><a href="#3-说说NIO的实现原理" class="headerlink" title="3 说说NIO的实现原理"></a>3 说说NIO的实现原理</h4><p>答：NIO由channel、buffer、selector三个核心组成，所有的IO都以一个channel开始，数据可以从buffer写到channel中，也能从channel读到buffer中。详情见<a href="https://blog.csdn.net/qq_43598179/article/details/122338780?spm=1001.2014.3001.5501">JavaNIO</a>。</p><h4 id="4-介绍一下Java的序列化与反序列化"><a href="#4-介绍一下Java的序列化与反序列化" class="headerlink" title="4 介绍一下Java的序列化与反序列化"></a>4 介绍一下Java的序列化与反序列化</h4><p>答：序列化可以将对象转换为字节序列，可以保存在磁盘上，也可以在网络上传输，且可以再次恢复成原来的对象，保证对象的完整性和可传递性。对象的序列化是指将一个Java对象写入IO流中，对象的反序列化是指从IO流程中恢复该对象。要支持序列化，则要实现Serializable这个接口。实现序列化，<code>ObjectOutputStream的writeObejct()</code>用以输出对象序列，<code>ObejctInputStream的readObject()</code>将对象序列恢复为对象。</p><h4 id="5-Serializable接口为什么需要定义serialVersionUID变量？"><a href="#5-Serializable接口为什么需要定义serialVersionUID变量？" class="headerlink" title="5 Serializable接口为什么需要定义serialVersionUID变量？"></a>5 Serializable接口为什么需要定义serialVersionUID变量？</h4><p>答：serialVersionUID代表序列化版本。在反序列化时，只要对象中所存的版本与当前类的版本一致，则允许做恢复数据的操作，否则抛出序列化版本不一致的错误。</p><p>如不定义serialVersionUID，则反序列化可能会出现冲突的情况有：实例序列化存在磁盘上，对类进行修改，再反序列化实例，则格式会发生冲突。 </p><h4 id="6-除了Java自带的序列化之外，你还了解哪些序列化工具？"><a href="#6-除了Java自带的序列化之外，你还了解哪些序列化工具？" class="headerlink" title="6 除了Java自带的序列化之外，你还了解哪些序列化工具？"></a>6 除了Java自带的序列化之外，你还了解哪些序列化工具？</h4><p>答：Json、Protobuf、Thrift、Avro</p><h4 id="7-如果不用JSON工具，该如何实现对实体类的序列化？"><a href="#7-如果不用JSON工具，该如何实现对实体类的序列化？" class="headerlink" title="7 如果不用JSON工具，该如何实现对实体类的序列化？"></a>7 如果不用JSON工具，该如何实现对实体类的序列化？</h4><p>答：Java原生的序列化机制，但效率较低。可以用6中的第三方类库。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(二)</title>
      <link href="/2022/01/05/220104/"/>
      <url>/2022/01/05/220104/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础（二）"><a href="#Java基础（二）" class="headerlink" title="Java基础（二）"></a>Java基础（二）</h1><h4 id="1-Java中有哪些容器（集合类）？"><a href="#1-Java中有哪些容器（集合类）？" class="headerlink" title="1. Java中有哪些容器（集合类）？"></a>1. Java中有哪些容器（集合类）？</h4><p>答：集合类主要由Collection（有Set、Queue、Tree三个子接口）和Map接口派生。有超多的实现类。</p><blockquote><p>Set：无序、元素不可重复</p><p>List：有序、元素可以重复</p><p>Queue：（FIFO）队列</p><p>Map：有映射关系的集合</p></blockquote><h4 id="2-容器线程安全和线程不安全的分别有哪些？"><a href="#2-容器线程安全和线程不安全的分别有哪些？" class="headerlink" title="2. 容器线程安全和线程不安全的分别有哪些？"></a>2. 容器线程安全和线程不安全的分别有哪些？</h4><p>答：<img data-src="/../../images/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%90%A6.png" alt="image-20220103170757463"></p><p>如需使用线程安全的集合类，可以用Collections工具类提供的synchronizedXxx（）方法，将其包装为线程安全的集合类。</p><h4 id="3-Map接口的实现类"><a href="#3-Map接口的实现类" class="headerlink" title="3. Map接口的实现类"></a>3. Map接口的实现类</h4><p>答：HashMap、TreeMap、LinkedHashMap、ConcurrentHashMap。</p><p>HashMap基于hash表，继承自AbstractMap，实现接口Map。它是线程不安全的，但他是性能最好的Map实现（相比HashTable，它在put采取加锁机制，而非同步）。它允许null key与null value，元素无序。对于多线程环境应采用ConcurrentHashMap。HashMap使用链表实现entry的存储，叫做bucket/bin。默认空间为16，权值为2。</p><h4 id="4-描述Map-put的过程"><a href="#4-描述Map-put的过程" class="headerlink" title="4. 描述Map put的过程"></a>4. 描述Map put的过程</h4><p>答：以HashMap为例。先判断数组是否为空，若为空进行第一次扩容；依据hash算法计算键值对索引；若当前位置为空，则直接插入；若不为空，且key存在，直接覆盖value，若key不存在，将数据链到尾端；若长度到8，则将其转为红黑树，将数据插入数中；若元素个数超过threshold，则再次进行扩容。</p><h4 id="5-如何得到一个线程安全的Map"><a href="#5-如何得到一个线程安全的Map" class="headerlink" title="5. 如何得到一个线程安全的Map"></a>5. 如何得到一个线程安全的Map</h4><p>答：使用ConcurrentHashMap；用工具类包装非线程安全的map</p><h4 id="6-HashMap的特点"><a href="#6-HashMap的特点" class="headerlink" title="6. HashMap的特点"></a>6. HashMap的特点</h4><p>答：非线程安全、允许null key null value的存在</p><h4 id="7-JDK7和JDK8中的HashMap有什么区别？"><a href="#7-JDK7和JDK8中的HashMap有什么区别？" class="headerlink" title="7.  JDK7和JDK8中的HashMap有什么区别？"></a>7.  JDK7和JDK8中的HashMap有什么区别？</h4><p>答：以前的HashMap采用数组+链表存储，一旦链表过长，效率会很低O（N）。而JDK8加入了红黑树来优化存储，它的时间复杂度降低为O（logN），而之前的Entry也变为了Node。</p><h4 id="8-HashMap底层实现原理"><a href="#8-HashMap底层实现原理" class="headerlink" title="8. HashMap底层实现原理"></a>8. HashMap底层实现原理</h4><p>答：数据结构是数组+ 链表，基于Hash算法，通过put、get存储获取对象。</p><p>存储：调用k的hashCode得到bucket位置，进行存储</p><p>获取：调用k的hashCode得到bucket位置，使用equals确定</p><p>发生碰撞时，将使用链表/红黑树组织数据。</p><h4 id="9-介绍HashMapd的扩容机制"><a href="#9-介绍HashMapd的扩容机制" class="headerlink" title="9. 介绍HashMapd的扩容机制"></a>9. 介绍HashMapd的扩容机制</h4><p>答：数组初始容量为16，是否扩充是由负载因子判断，默认0.75。</p><h4 id="10-HashMap中的循环链表如何产生"><a href="#10-HashMap中的循环链表如何产生" class="headerlink" title="10. HashMap中的循环链表如何产生"></a>10. HashMap中的循环链表如何产生</h4><p>答：<a href="https://blog.csdn.net/qq36846776/article/details/110263475">循环链表如何产生可以看这篇。</a></p><h4 id="11-HashMap为什么用红黑树而不用B树？"><a href="#11-HashMap为什么用红黑树而不用B树？" class="headerlink" title="11. HashMap为什么用红黑树而不用B树？"></a>11. HashMap为什么用红黑树而不用B树？</h4><p>答：B/B+树多用于外存，而在数据量不高的情况下，数据都会挤到一个节点里，这时候遍历效率就退化为链表。</p><h4 id="12-HashMap为什么线程不安全？"><a href="#12-HashMap为什么线程不安全？" class="headerlink" title="12. HashMap为什么线程不安全？"></a>12. HashMap为什么线程不安全？</h4><p>答：在并发执行put时，可能形成循环链表，从而引起死循环。</p><h4 id="13-HashMap如何实现线程安全？"><a href="#13-HashMap如何实现线程安全？" class="headerlink" title="13. HashMap如何实现线程安全？"></a>13. HashMap如何实现线程安全？</h4><p>答：直接使用ConcurrentHashMap；使用HashTable类；用方法包装HashMap。</p><h4 id="14-HashMap是如何解决哈希冲突的？"><a href="#14-HashMap是如何解决哈希冲突的？" class="headerlink" title="14. HashMap是如何解决哈希冲突的？"></a>14. HashMap是如何解决哈希冲突的？</h4><p>答：数组元素为单向链表类型。当链表长度达到一个阈值时，链表会被转为红黑树存储提高性能，反之缩小到一个阈值，红黑树会被转为单向链表。</p><h4 id="15-说一说HashMap和HashTable的区别"><a href="#15-说一说HashMap和HashTable的区别" class="headerlink" title="15. 说一说HashMap和HashTable的区别"></a>15. 说一说HashMap和HashTable的区别</h4><p>答：HashMap线程不安全，允许null key、value</p><p>HashTable线程安全，不允许null作为key和value</p><h4 id="16-HashMap与ConcurrentHashMap有什么区别？"><a href="#16-HashMap与ConcurrentHashMap有什么区别？" class="headerlink" title="16. HashMap与ConcurrentHashMap有什么区别？"></a>16. HashMap与ConcurrentHashMap有什么区别？</h4><p>答：HashMap线程不安全，在多线程对Map进行修改时会产生数据不一致问题，在并发插入数据时会导致链表成环，查找时会发生死循环。</p><p><a href="https://blog.csdn.net/weixin_44460333/article/details/86770169">ConcurrentHashMap</a>是线程安全的。采用了减少锁粒度的方法，尽量减少因为竞争锁而导致的阻塞与冲突，而且ConcurrentHashMap的检索操作是不需要锁的。</p><h4 id="17-介绍一下ConcurrentHashMap是怎么实现的？"><a href="#17-介绍一下ConcurrentHashMap是怎么实现的？" class="headerlink" title="17. 介绍一下ConcurrentHashMap是怎么实现的？"></a>17. 介绍一下ConcurrentHashMap是怎么实现的？</h4><p>答：JDK1.7时ConcurrentHashMap，它采取了分段锁技术。其中Segment继承于ReentranLock，HashEntry用于存储键值对数据。Segment结构与HashMap相似，数组+链表。</p><pre class="mermaid">classDiagram    ConcurrentHashMap <|-- Segment    Segment <|-- HashEntry      class HashEntry{      }      class Segment{      }</pre><p>put方法：通过Key定位到Segment，随后在Segment中具体Put。先尝试获取锁，若失败则表明有其他线程存在竞争，利用scanAndLockForPut（）自旋获取锁。将当前Segment中的table通过key的hashCode定位到HashEntry。遍历当前Entry，若不为空且当前key相等，则覆盖旧value；若为空则需要新建HashEntry加如Segment，同时判断是否需要扩容。解除Segment的锁。</p><p>get方法：将key经过Hash定位到具体Segment，再Hash定位到具体元素，整体过程无需加锁。</p><p>JDK1.8时，由于查询遍历链表效率太低，抛弃Segment分段锁，采用CAS+synchronized保证并发安全，HashEntry改为Node，也加入了红黑树提高查询效率。</p><h4 id="18-ConcurrentHashMap是怎么分段分组的？"><a href="#18-ConcurrentHashMap是怎么分段分组的？" class="headerlink" title="18. ConcurrentHashMap是怎么分段分组的？"></a>18. ConcurrentHashMap是怎么分段分组的？</h4><p>答：17中put、get方法详解。</p><h4 id="19-说一说你对LinkedHashMap的理解"><a href="#19-说一说你对LinkedHashMap的理解" class="headerlink" title="19. 说一说你对LinkedHashMap的理解"></a>19. 说一说你对LinkedHashMap的理解</h4><p>答：HashMap+双向链表以维护插入（默认）/读取顺序一致。很多方法直接继承自HashMap。</p><h4 id="20-请介绍LinkedHashMap的底层原理"><a href="#20-请介绍LinkedHashMap的底层原理" class="headerlink" title="20. 请介绍LinkedHashMap的底层原理"></a>20. 请介绍LinkedHashMap的底层原理</h4><p>答：在HashMap任意两个节点加了两条连线，（before指针、after指针）形成了一个以head为头结点的双向链表，故每次put进来的Entry会将它插入到双向链表的尾部。</p><h4 id="21-请介绍TreeMap的底层原理"><a href="#21-请介绍TreeMap的底层原理" class="headerlink" title="21. 请介绍TreeMap的底层原理"></a>21. 请介绍TreeMap的底层原理</h4><p>答：TreeMap基于红黑树实现，时间复杂度为log（N）。映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，</p><h4 id="22-Map和Set有什么区别？"><a href="#22-Map和Set有什么区别？" class="headerlink" title="22. Map和Set有什么区别？"></a>22. Map和Set有什么区别？</h4><p>答：Map：有映射关系的集合，key无序且不能重复。</p><p>Set：无序、元素不可重复。</p><h4 id="23-List和Set有什么区别？"><a href="#23-List和Set有什么区别？" class="headerlink" title="23. List和Set有什么区别？"></a>23. List和Set有什么区别？</h4><p>答：List：有序，可重复</p><p>Set：无序、不可重复</p><h4 id="24-ArrayList和LinkedList有什么区别？"><a href="#24-ArrayList和LinkedList有什么区别？" class="headerlink" title="24. ArrayList和LinkedList有什么区别？"></a>24. ArrayList和LinkedList有什么区别？</h4><p>答：ArrayList实现基于数组，LinkedList基于双向链表。</p><h4 id="25-有哪些线程安全的List？"><a href="#25-有哪些线程安全的List？" class="headerlink" title="25. 有哪些线程安全的List？"></a>25. 有哪些线程安全的List？</h4><p>答：Vector、SynchronizedList、CopyOnWriteArrayList</p><h4 id="26-介绍一下ArrayList的数据结构？"><a href="#26-介绍一下ArrayList的数据结构？" class="headerlink" title="26. 介绍一下ArrayList的数据结构？"></a>26. 介绍一下ArrayList的数据结构？</h4><p>答：基于数组实现。默认数组长度为10，超出限制时会增加到50%的容量。</p><h4 id="27-谈谈CopyOnWriteArrayList的原理"><a href="#27-谈谈CopyOnWriteArrayList的原理" class="headerlink" title="27. 谈谈CopyOnWriteArrayList的原理"></a>27. 谈谈CopyOnWriteArrayList的原理</h4><p>答：在对一块内存进行修改时，不直接对内存块进行写操作，而是拷贝一份内存，在新内存中进行写操作，之后，将原本只想的内存指针指到新的内存，原内存可以被回收。读取操作无需同步及锁，但写操作需要加锁。适用于多读少写。</p><h4 id="28-说一说TreeSet和HashSet的区别"><a href="#28-说一说TreeSet和HashSet的区别" class="headerlink" title="28. 说一说TreeSet和HashSet的区别"></a>28. 说一说TreeSet和HashSet的区别</h4><p>答：元素均不能重复，线程不安全。但HashSet中元素可以为null，TreeSet内元素不能为null。HashSet无序，TreeSet支持自然排序、定制排序。HashSet基于Hash表实现，TreeSet基于红黑树实现。</p><h4 id="29-说一说HashSet的底层结构"><a href="#29-说一说HashSet的底层结构" class="headerlink" title="29. 说一说HashSet的底层结构"></a>29. 说一说HashSet的底层结构</h4><p>答：基于HashMap实现，默认Constructor时一个初始容量为16，负载因子为0.75的HashMap。而放入HashSet的元素由HashMap的key保存，value时PRESENT，是一个静态Object对象。</p><h4 id="30-BlockingQueue中有哪些方法，为什么这样设计？"><a href="#30-BlockingQueue中有哪些方法，为什么这样设计？" class="headerlink" title="30. BlockingQueue中有哪些方法，为什么这样设计？"></a>30. BlockingQueue中有哪些方法，为什么这样设计？</h4><p>答：阻塞队列，基于ReentranQueue。它是一个接口。 </p><table><thead><tr><th align="center"></th><th align="center">抛异常</th><th align="center">特定值</th><th align="center">阻塞</th><th align="center">超时</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center">put(e)</td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><ul><li>抛异常：如果操作无法立即执行，则抛一个异常；</li><li>特定值：如果操作无法立即执行，则返回一个特定的值(一般是 true / false)。</li><li>阻塞：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；</li><li>超时：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true / false)。</li></ul><h4 id="31-BlockingQueue是怎么实现的？"><a href="#31-BlockingQueue是怎么实现的？" class="headerlink" title="31. BlockingQueue是怎么实现的？"></a>31. BlockingQueue是怎么实现的？</h4><p>答：它是一个接口，实现类有ArrayBlockingQueue、DelayQueue、 LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue等。区别主要在存储结构和对元素操作。</p><h4 id="32-Stream（不是IOStream）有哪些方法？"><a href="#32-Stream（不是IOStream）有哪些方法？" class="headerlink" title="32. Stream（不是IOStream）有哪些方法？"></a>32. Stream（不是IOStream）有哪些方法？</h4><p>答：它是Java对集合操作的优化，相比于Iterator。Stream的速度非常快。</p><pre class="mermaid">graph LR;A(获取数据源)-->B(进行逻辑转换操作)B-->C(归约操作形成新的流)</pre><p>操作分中间操作与末端（规约）操作。</p><p>中间操作：对容器的处理过程，包括排序，筛选，映射。</p><ul><li>filter(Predicate predicate)：过滤Stream中所有不符合predicate的元素。</li><li>mapToXxx(ToXxxFunction mapper)：使用ToXxxFunction对流中的元素执行一对一的转换，该方法返回的新流中包含了ToXxxFunction转换生成的所有元素。</li><li>peek(Consumer action)：依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元素。该方法主要用于调试。</li><li>distinct()：该方法用于排序流中所有重复的元素（判断元素重复的标准是使用equals()比较返回true）。这是一个有状态的方法。</li><li>sorted()：该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。</li><li>limit(long maxSize)：该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个有状态的、短路方法。</li></ul><p>末端操作：将流中数据整合输出为一个结果</p><ul><li>forEach(Consumer action)：遍历流中所有元素，对每个元素执行action。</li><li>toArray()：将流中所有元素转换为一个数组。</li><li>reduce()：该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。</li><li>min()：返回流中所有元素的最小值。</li><li>max()：返回流中所有元素的最大值。</li><li>count()：返回流中所有元素的数量。</li><li>anyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合Predicate条件。</li><li>noneMatch(Predicate predicate)：判断流中是否所有元素都不符合Predicate条件。</li><li>findFirst()：返回流中的第一个元素。</li><li>findAny()：返回流中的任意一个元素。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础知识复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(一)</title>
      <link href="/2022/01/04/220103/"/>
      <url>/2022/01/04/220103/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h1><h3 id="1-“一次编写，到处运行“？"><a href="#1-“一次编写，到处运行“？" class="headerlink" title="1. “一次编写，到处运行“？"></a>1. “一次编写，到处运行“？</h3><p>答：JVM（java虚拟机）是实现Java跨平台的关键，充当桥梁。不同平台需要安装不同JVM，无需改动Java程序。</p><pre class="mermaid">graph LRA[java源代码.java] -->|编译器| B[字节码.class]B -->|解释执行 via JVM| C[机器码]</pre><h3 id="2-一个Java文件里可以有多个类吗（不含内部类）？"><a href="#2-一个Java文件里可以有多个类吗（不含内部类）？" class="headerlink" title="2. 一个Java文件里可以有多个类吗（不含内部类）？"></a>2. 一个Java文件里可以有多个类吗（不含内部类）？</h3><p>答：可以。只能有一个被public修饰的类，主类名必须与java文件名一致。</p><h3 id="3-说一说你对Java访问权限的了解"><a href="#3-说一说你对Java访问权限的了解" class="headerlink" title="3.说一说你对Java访问权限的了解"></a>3.说一说你对Java访问权限的了解</h3><p>答：对成员变量/成员方法：</p><blockquote><p>private：该成员可以被该类内部成员访问；</p><p>default：该成员可以被该类内部成员访问，也可以被同一包下其他类的成员访问</p><p>protected：该成员可以被该类内部成员访问，也可以被同一包下其他类的成员访问，还可以被其子类访问</p><p>public：任意包下，任意类的成员进行访问。</p></blockquote><p>对类：</p><blockquote><p>default：同一包下其他类访问</p><p>public：任意包下任意类访问</p></blockquote><h3 id="4-介绍一下Java的数据类型"><a href="#4-介绍一下Java的数据类型" class="headerlink" title="4. 介绍一下Java的数据类型"></a>4. 介绍一下Java的数据类型</h3><p>答：基本数据类型：（前七种均可互相类型转换）</p><table><thead><tr><th align="center">数据类型</th><th align="center">数据范围</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1字节（8位） -2^7——2^7-1</td></tr><tr><td align="center">short</td><td align="center">2字节（16位） -2^15—— 2 ^15-1</td></tr><tr><td align="center">int</td><td align="center">4字节（32位） -2^31—— 2 ^31-1</td></tr><tr><td align="center">long</td><td align="center">8字节（64位） -2^63—— 2 ^63-1x</td></tr><tr><td align="center">float</td><td align="center">-3.4*10^38 ~ 3.4*10^38</td></tr><tr><td align="center">double</td><td align="center">8字节（64位） -1.8*10^308 ~ 1.8*10^308</td></tr><tr><td align="center">char</td><td align="center">2字节（16位）\u000 — \ufff</td></tr><tr><td align="center">boolean</td><td align="center">不同JVM有不同实现机制</td></tr></tbody></table><p>引用数据类型：（本质是指针）<em>要了解引用及引用对象存放的位置。</em></p><blockquote><p>数组、类、接口</p></blockquote><h3 id="5-int数据范围"><a href="#5-int数据范围" class="headerlink" title="5.  int数据范围"></a>5.  int数据范围</h3><p>答：4字节 32位 -2^31-2^31-1。</p><h3 id="6-全局变量、局部变量"><a href="#6-全局变量、局部变量" class="headerlink" title="6. 全局变量、局部变量"></a>6. 全局变量、局部变量</h3><p>答：变量分为局部变量和成员变量。</p><p>成员变量</p><blockquote><p>在类内定义；有默认初始值；static修饰的成员变量叫类变量，存储于方法区，生命周期与类相同；未被static修饰的成员变量叫实例变量，存储与对象所在的堆内存，生命周期跟对象相同。</p></blockquote><p>局部变量</p><blockquote><p>在方法里定义；无默认初始值；存储与栈内存，作用范围结束，空间自动释放。</p></blockquote><h3 id="7-实例变量默认值"><a href="#7-实例变量默认值" class="headerlink" title="7. 实例变量默认值"></a>7. 实例变量默认值</h3><p>答：</p><table><thead><tr><th align="center">变量</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">0</td></tr><tr><td align="center">short</td><td align="center">0</td></tr><tr><td align="center">int</td><td align="center">0</td></tr><tr><td align="center">long</td><td align="center">0L</td></tr><tr><td align="center">float</td><td align="center">0.0F</td></tr><tr><td align="center">double</td><td align="center">0.0</td></tr><tr><td align="center">char</td><td align="center">‘\u0000’</td></tr><tr><td align="center">boolean</td><td align="center">false</td></tr></tbody></table><h3 id="8-为啥有包装类"><a href="#8-为啥有包装类" class="headerlink" title="8. 为啥有包装类"></a>8. 为啥有包装类</h3><p>答：Java是面对对象的语言，但8中基本数据类型不具备对象的特性，为了解决这个问题，Java为每个基本数据类型定义了一个对应的引用类型，就是包装类。</p><h3 id="9-自动装拆箱的应用场景"><a href="#9-自动装拆箱的应用场景" class="headerlink" title="9. 自动装拆箱的应用场景"></a>9. 自动装拆箱的应用场景</h3><p>答：自动装箱：把一个基本类型的数据直接赋值给对应包装类型。</p><p>自动拆箱：把一个包装类型的数据直接赋值给对应基本类型。</p><p>例如：参数为包装类型，数据为基本类型，直接传入。</p><h3 id="10-对Integer-Double如何判断相等"><a href="#10-对Integer-Double如何判断相等" class="headerlink" title="10. 对Integer/Double如何判断相等"></a>10. 对Integer/Double如何判断相等</h3><p>答：无法比较。数据类型不同不能用==。转为char比较时，浮点数带小数点，整数不带。Compare to只能对相同类型进行比较。</p><h3 id="11-int和Integer有什么区别，二者在做-运算时会得到什么结果？"><a href="#11-int和Integer有什么区别，二者在做-运算时会得到什么结果？" class="headerlink" title="11. int和Integer有什么区别，二者在做==运算时会得到什么结果？"></a>11. int和Integer有什么区别，二者在做==运算时会得到什么结果？</h3><p>答：一个基本数据类型，一个包装类。比较时直接拆箱，==返回true，否则返回false。</p><h3 id="12-面向对象是？"><a href="#12-面向对象是？" class="headerlink" title="12. 面向对象是？"></a>12. 面向对象是？</h3><p>答：它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。尽可能运用人类的自然思维方式，将事物抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p><h3 id="13-它的三大特征是？"><a href="#13-它的三大特征是？" class="headerlink" title="13. 它的三大特征是？"></a>13. 它的三大特征是？</h3><p>答：封装、继承、多态。封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。</p><h3 id="14-封装是什么？为什么要有？"><a href="#14-封装是什么？为什么要有？" class="headerlink" title="14. 封装是什么？为什么要有？"></a>14. 封装是什么？为什么要有？</h3><p>答：将对象的状态信息隐藏在对象内部，使得外部无法进行直接操作和修改。</p><p>可以实现以下目的：</p><ul><li>隐藏类的实现细节；</li><li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li><li>可进行数据检查，从而有利于保证对象信息的完整性；</li><li>便于修改，提高代码的可维护性。</li></ul><h3 id="15-多态是什么？"><a href="#15-多态是什么？" class="headerlink" title="15. 多态是什么？"></a>15. 多态是什么？</h3><p>答：即向上转型。Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，由系统自动完成。</p><p>当把一个子类对象直接赋给父类引用变量时，例如 <code>BaseClass obj = new SubClass();</code>，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p><h3 id="16-Java中的多态是怎么实现的？"><a href="#16-Java中的多态是怎么实现的？" class="headerlink" title="16. Java中的多态是怎么实现的？"></a>16. Java中的多态是怎么实现的？</h3><p>答：将参数设为父类型，传参时可以传入父类型的某个字类型的实例，实现多态。</p><h3 id="17-为何只能单继承？"><a href="#17-为何只能单继承？" class="headerlink" title="17. 为何只能单继承？"></a>17. 为何只能单继承？</h3><p>答：Java中一个类只能有一个直接父类，而不能<strong>直接</strong>继承多个父类，但可以有任意多个间接父类。因为若两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p><h3 id="18-重写和重载的区别？"><a href="#18-重写和重载的区别？" class="headerlink" title="18. 重写和重载的区别？"></a>18. 重写和重载的区别？</h3><p>答：重写：子类重写父类允许访问的方法（除private、final、static外）。”两同两小一大“，方法名，参数必须相同；异常范围、返回值类型要小于等于父类方法；修饰符要大于等于父类方法。</p><p>重载：同一类中、父类子类间。方法名必须相同，其余可不同。</p><h3 id="19-构造方法能否重写？"><a href="#19-构造方法能否重写？" class="headerlink" title="19. 构造方法能否重写？"></a>19. 构造方法能否重写？</h3><p>答：不能，构造方法必须与类名相同。如若子类重写父类构造方法，则子类中会有与类命不同的构造方法，矛盾。</p><h3 id="20-Object类中的方法"><a href="#20-Object类中的方法" class="headerlink" title="20. Object类中的方法"></a>20. Object类中的方法</h3><p>答：</p><table><thead><tr><th align="left">方法名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Class&lt;?&gt; getClass()</td><td align="left">返回该对象的类</td></tr><tr><td align="left">boolean equals(Object obj)</td><td align="left">判断两个对象是否相等</td></tr><tr><td align="left">int hashCode()</td><td align="left">返回hashCode值</td></tr><tr><td align="left">String toString()</td><td align="left">返回字符串表示</td></tr></tbody></table><h3 id="21-hashCode（）和equals（）的关系"><a href="#21-hashCode（）和equals（）的关系" class="headerlink" title="21. hashCode（）和equals（）的关系"></a>21. hashCode（）和equals（）的关系</h3><p>答：hashCode返回该对象的hashCode值，equals则是判断两对象是否相同。即hashCode相等，equals不一定为true；若equals若为true，hashCode一定相等。</p><h3 id="22-为何要重写hashCode（）和equals（）"><a href="#22-为何要重写hashCode（）和equals（）" class="headerlink" title="22. 为何要重写hashCode（）和equals（）"></a>22. 为何要重写hashCode（）和equals（）</h3><p>答：默认的equals判断方法和我们实际需求往往不一致。hashCode通常与equals有联动关系，故需要一同重写。</p><h3 id="23-和equals（）有何区别"><a href="#23-和equals（）有何区别" class="headerlink" title="23. ==和equals（）有何区别"></a>23. ==和equals（）有何区别</h3><p>答：==</p><ul><li><p>基本数据类型：  判断值</p></li><li><p>引用数据类型：  判断两个对象的内存地址是否相同</p><p>equals</p></li><li><p>Object默认比较内存地址</p></li><li><p>重写后根据用户需求</p></li></ul><h3 id="24-String方法"><a href="#24-String方法" class="headerlink" title="24. String方法"></a>24. String方法</h3><p>答：**<font color=red>可以看看部分方法的源码</font>**</p><ul><li>String[] split(String regex)：以指定的规则将此字符串分割成数组；</li><li>String trim()：删除字符串前导和后置的空格；</li><li>int indexOf(String str)：返回子串在此字符串首次出现的索引；</li><li>int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；</li><li>boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；</li><li>boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；</li><li>String toUpperCase()：将此字符串中所有的字符大写；</li><li>String toLowerCase()：将此字符串中所有的字符小写；</li><li>String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；</li><li>String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。</li></ul><h3 id="25-String能否被继承？"><a href="#25-String能否被继承？" class="headerlink" title="25. String能否被继承？"></a>25. String能否被继承？</h3><p>答：不能。String类由final修饰，是个不变类。存储String用的数组是个Private，也被final修饰，没有修改他的方法。</p><h3 id="26-String和StringBuffer区别？"><a href="#26-String和StringBuffer区别？" class="headerlink" title="26. String和StringBuffer区别？"></a>26. String和StringBuffer区别？</h3><p>答：String：不变类，一旦被创建，不可改变，直至被销毁。</p><p>StringBuffer：其对象代表一个字符序列可变的字符串，可使用toString转为String对象。</p><h3 id="27-StringBuffer和StringBuilder区别？"><a href="#27-StringBuffer和StringBuilder区别？" class="headerlink" title="27. StringBuffer和StringBuilder区别？"></a>27. StringBuffer和StringBuilder区别？</h3><p>答：其对象均代表一个字符序列可变的字符串，但StringBuffer是线程安全的，StringBuilder时非线程安全的，性能略高。</p><h3 id="28-创建字符串时，推荐new还是”“？"><a href="#28-创建字符串时，推荐new还是”“？" class="headerlink" title="28. 创建字符串时，推荐new还是”“？"></a>28. 创建字符串时，推荐new还是”“？</h3><p>答：”“创建时，JVM会用常量池来管理这个字符串；new会创建对象，JVM会先使用常量池来管理直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。</p><h3 id="29-对字符串拼接的理解"><a href="#29-对字符串拼接的理解" class="headerlink" title="29. 对字符串拼接的理解"></a>29. 对字符串拼接的理解</h3><p>答：‘+’适用于两者均为直接量、StringBuilder适用于字符串包含变量且不要求线程安全、String Buffer适用于字符串包含变量且要求线程安全、String.concat适用于包含变量的2个字符串拼接。</p><h3 id="30-字符串相加的底层如何实现"><a href="#30-字符串相加的底层如何实现" class="headerlink" title="30. 字符串相加的底层如何实现"></a>30. 字符串相加的底层如何实现</h3><p>答：若为直接量，则编译器会直接优化为一个完整的字符串。若包含变量，则编译器会使用StringBuilder进行优化，自动创建StringBuilder实例并调用append方法。</p><h3 id="31-String-a-“abc”-，说一下这个过程会创建什么，放在哪里？"><a href="#31-String-a-“abc”-，说一下这个过程会创建什么，放在哪里？" class="headerlink" title="31. String a = “abc”; ，说一下这个过程会创建什么，放在哪里？"></a>31. String a = “abc”; ，说一下这个过程会创建什么，放在哪里？</h3><p>答：JVM使用常量池管理字符串直接量。执行过程：先检查常量池中是否已经存在”abc“，若没有则存入常量池；若有，则复用，引用赋值给变量a。</p><h3 id="32-new-String-“abc”-是去了哪里，仅仅是在堆里面吗？"><a href="#32-new-String-“abc”-是去了哪里，仅仅是在堆里面吗？" class="headerlink" title="32. new String(“abc”) 是去了哪里，仅仅是在堆里面吗？"></a>32. new String(“abc”) 是去了哪里，仅仅是在堆里面吗？</h3><p>答：先将abc存入常量池，再创建String对象，保存在堆内存里，然后堆中对象数据再指向常量池中直接量。</p><h3 id="33-接口和抽象类有什么区别？"><a href="#33-接口和抽象类有什么区别？" class="headerlink" title="33. 接口和抽象类有什么区别？"></a>33. 接口和抽象类有什么区别？</h3><p>答：接口是一种规范，规定能够调用哪些服务，该如何调用。抽象类体现了一种模板式设计，可以作为多个子类的抽象子类。</p><p>接口中只能包含抽象方法、静态方法、默认方法和私有方法，只能定义静态变量，不能定义普通成员变量，不包含构造器，不包含初始化块，可以实现多继承，即一个类可以直接实现多个接口。抽象类可以包含普通法，可以定义静态变量、普通成员变量，可以包含构造器、初始化块。</p><p>二者均无法被实例化，只能被实现和继承。他们都可以包含抽象方法，而其子类都必须实现这些抽象方法。</p><h3 id="34-接口中可以有构造函数吗？"><a href="#34-接口中可以有构造函数吗？" class="headerlink" title="34. 接口中可以有构造函数吗？"></a>34. 接口中可以有构造函数吗？</h3><p>答：不可以。 参看33</p><h3 id="35-谈谈你对面向接口编程的理解"><a href="#35-谈谈你对面向接口编程的理解" class="headerlink" title="35. 谈谈你对面向接口编程的理解"></a>35. 谈谈你对面向接口编程的理解</h3><p>答：可以降低耦合，提高系统可扩展性和可维护性。</p><h3 id="36-遇到过异常吗，如何处理"><a href="#36-遇到过异常吗，如何处理" class="headerlink" title="36. 遇到过异常吗，如何处理"></a>36. 遇到过异常吗，如何处理</h3><p>答：捕获异常（try catch）、处理异常、回收资源</p><h3 id="37-说一说Java的异常机制"><a href="#37-说一说Java的异常机制" class="headerlink" title="37. 说一说Java的异常机制"></a>37. 说一说Java的异常机制</h3><p>答：处理异常的语句有try、catch、finally。try负责包裹业务代码，catch负责捕获和处理异常，finally用于回收资源。</p><p>当出现异常，系统会创建一个异常对象，由JVM需寻找可以处理该异常的catch块，并将异常对象交由它处理。除此之外，还可以使用throw主动抛出异常，交由JVM处理。而异常机制会逐层向外传递，直到main方法，则JVM终止程序，打印异常跟踪栈的信息。</p><h3 id="38-Java的异常接口"><a href="#38-Java的异常接口" class="headerlink" title="38. Java的异常接口"></a>38. Java的异常接口</h3><p>答：Throwable是顶层父类，直接子类分别是Error、Exception。</p><p>Error是错误，一般与虚拟机相关，无需使用catch捕获，无需抛出</p><p>Exception是异常，被分为Checked异常、Runtime异常。RuntimeException及其子类的实例被称为Runtime异常，其余都是Checked异常。Checked异常必须被显式处理，否则编译就会发生错误。Runtime异常则无需显式声明抛出，如需捕获，也可使用try catch实现。</p><h3 id="39-finally是无条件执行吗？"><a href="#39-finally是无条件执行吗？" class="headerlink" title="39. finally是无条件执行吗？"></a>39. finally是无条件执行吗？</h3><p>答：是，不论什么情况，finally总是被执行。除非在try…catch块中使用System.exit(1)直接退出执行。</p><h3 id="40-在finally中return会发生什么？"><a href="#40-在finally中return会发生什么？" class="headerlink" title="40. 在finally中return会发生什么？"></a>40. 在finally中return会发生什么？</h3><p>答：finally中一般不要使用是方法终止的语句，如return、throw等，使用后会使try catch中的return、throw失效。因为在try catch块中遇到return、throw不会立刻执行，而是去找异常处理流程中是否包括finally块，若没有，则立刻执行终止方法。否则要先执行finally中的语句。</p><h3 id="41-对static关键字的理解"><a href="#41-对static关键字的理解" class="headerlink" title="41. 对static关键字的理解"></a>41. 对static关键字的理解</h3><p>答：可用于修饰类中的成员变量、方法、初始化块、内部类（接口、枚举），被其修饰的成员就是类成员，它属于类，并不属于单个对象。类成员不能访问实例成员。</p><h3 id="42-static修饰的类能不能被继承"><a href="#42-static修饰的类能不能被继承" class="headerlink" title="42. static修饰的类能不能被继承"></a>42. static修饰的类能不能被继承</h3><p>答：可以。可用来修饰内部类，成为静态内部类。</p><h3 id="43-static和final区别"><a href="#43-static和final区别" class="headerlink" title="43. static和final区别"></a>43. static和final区别</h3><p>答：static可以修饰成员变量、方法、初始化块、内部类</p><p>类变量：属于类，存储在方法区，并不存储在堆中，建议通过类名访问。</p><p>类方法：属于类，建议通过类名访问。</p><p>静态块：类加载时被隐式调用，之后不会被调用</p><p>静态内部类：它内部包含静态和非静态成员。它不能访问外部类的实例成员，只能访问外部类的静态成员。</p><p>final可以修饰类、变量、方法</p><p>final类：不可被继承</p><p>final变量：一旦获得初始值，不可被修改</p><p>final方法：不可被重写</p><h3 id="44-对泛型的理解"><a href="#44-对泛型的理解" class="headerlink" title="44. 对泛型的理解"></a>44. 对泛型的理解</h3><p>答：&lt;T&gt;，Java中的泛型是假泛型，赋值时泛型信息其实会被擦除。</p><p>泛型类：public class xxx &lt;T&gt;</p><p>泛型接口：public interface Generator &lt;T&gt;</p><p>泛型方法：public static &lt;T&gt; void xxx</p><h3 id="45-泛型擦除是什么"><a href="#45-泛型擦除是什么" class="headerlink" title="45. 泛型擦除是什么"></a>45. 泛型擦除是什么</h3><p>答：当把具有泛型信息的对象赋值给没有泛型信息的变量时，&lt;&gt;中的所有信息都会被擦除。</p><h3 id="46-List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别"><a href="#46-List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别" class="headerlink" title="46. List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别?"></a>46. List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别?</h3><p>答：？是类型通配符，List&lt;?&gt;代表元素类型未知的List</p><p>List&lt;? super T&gt; 代表设置？的下限，即必须是T的父类</p><p>List&lt;? extends T&gt;代表设置？的上限，必须是T的字类。</p><h3 id="47-Java反射机制"><a href="#47-Java反射机制" class="headerlink" title="47. Java反射机制"></a>47. Java反射机制</h3><p>答：反射使得运行中的Java程序可以获取自身信息，可以操作类或对象的内部属性。<strong>JVM在运行时才动态加载类/调用方法，访问属性，无需事先知道运行对象是谁。</strong></p><ul><li>获得Class对象</li><li>判断某个对象是否为某个类的实例，还可访问成员</li><li>创建实例</li></ul><h3 id="48-Java反射在实际项目中有哪些应用场景？"><a href="#48-Java反射在实际项目中有哪些应用场景？" class="headerlink" title="48. Java反射在实际项目中有哪些应用场景？"></a>48. Java反射在实际项目中有哪些应用场景？</h3><p>答：使用JDBC，使用反射加载驱动；框架配置是解析出的类是字符串，需要利用反射机制实例化；AOP的实现方案是在程序运行时创建目标对象的代理类，必须由反射机制实现。</p><h3 id="49-说一说Java的四种引用方式"><a href="#49-说一说Java的四种引用方式" class="headerlink" title="49. 说一说Java的四种引用方式"></a>49. 说一说Java的四种引用方式</h3><p>答：包括强引用、软引用、弱引用、虚引用。目的在于让程序员决定某些对象的生命周期，并且有利于JVM进行gc。</p><p>强引用：创建对象并赋值给引用变量，永远不会被垃圾回收</p><p>类似<code> String str = &#39;abc&#39;</code>就是强引用</p><p>软引用：常用于内存敏感的程序里，只要内存足够，便不会被回收；一旦内存空间不足，就会被回收。</p><p>用<code>SoftReference</code>表示软引用</p><p>弱引用：相比软引用，级别更低，只要JVM进行垃圾回收，无论内存是否充足，都会被回收。</p><p>用<code>WeakReference</code>表示弱引用</p><p>虚引用：类似于完全没有引用，用于跟踪对象被垃圾回收的状态，必须和引用队列联合使用。</p><p>用<code>PhantomReference</code>表示虚引用</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法查找</title>
      <link href="/2022/01/02/220102/"/>
      <url>/2022/01/02/220102/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>一直以来，都以为二分法很简单，但一写代码就出问题，感觉还是理解得不够透彻。</p><p>二分法可以有两种写法，定义区间不同，写法不同。值得注意的是，此区间在循环过程中保持不变，即mid改变，但区间性质不变。</p><ol><li><p>target位于左闭右闭 []区间内</p><p>此时，low==high可以成立</p><p><img data-src="/../../images/%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%881%EF%BC%89.png"></p><p>假设target 为2，则下一步，high = mid - 1（保持闭区间，且无需再次查找mid处）</p><p><img data-src="/../../images/%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%882%EF%BC%89.png"></p><p>同理，low = mid + 1</p><p>故用Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">             <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>( nums[mid] == target)&#123;</span><br><span class="line">                 <span class="keyword">return</span> mid;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &gt; target)&#123;</span><br><span class="line">                 high = mid - <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                 low = mid + <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>target位于左闭右开 []区间内</p><p>此时，low==high无意义，因为high本身并不在区间内。</p><p><img data-src="/../../images/%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%883%EF%BC%89.png"></p><p>假设target 为2，则下一步，high = mid （保持左闭右开区间，且无需再次查找mid处）</p><p><img data-src="/../../images/%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%884%EF%BC%89.png"></p><p>但由于左侧为闭区间，则low = mid + 1</p><p>故用Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length;</span><br><span class="line">         <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">             <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>( nums[mid] == target)&#123;</span><br><span class="line">                 <span class="keyword">return</span> mid;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &gt; target)&#123;</span><br><span class="line">                 high = mid;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                 low = mid + <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h4><p>难度：简单</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。nums为<strong>无重复元素</strong>的<strong>升序</strong>排列数组</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p></blockquote><p>插入位置分四种情况。target在所有元素之前，target恰在数组中，target在数组元素之间，target在所有元素之后。</p><p>暴力解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">                   <span class="keyword">return</span> i;  <span class="comment">//因数组升序，故一旦大于target，便可插入当前位置。</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> nums.length;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">               <span class="keyword">int</span> mid = low + ((high-low)&gt;&gt;<span class="number">1</span>); <span class="comment">//此处若采取移位运算，必须带括号</span></span><br><span class="line">               <span class="keyword">if</span>(target == nums[mid])&#123;</span><br><span class="line">                   <span class="keyword">return</span> mid;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                   low = mid + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                   high = mid - <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> high + <span class="number">1</span>; <span class="comment">//计算可知，其余三种情况皆可由high+1解出</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql创建触发器遇到的问题ERROR 1415 (0A000)</title>
      <link href="/2019/08/09/190808/"/>
      <url>/2019/08/09/190808/</url>
      
        <content type="html"><![CDATA[<p>刚在看《MySQL必知必会》这本书，在第25章出现一段代码无法正常运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">    -&gt; FOR EACH ROW SELECT &#x27;Product added&#x27;;</span><br></pre></td></tr></table></figure><p>报错</p><blockquote><p>ERROR 1415 (0A000): Not allowed to return a result set from a trigger</p></blockquote><p>在上网查找之后发现，是因为在MySQL后期版本内不支持这种写法。这种写法会返回一个结果集，所以报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">    -&gt; FOR EACH ROW SELECT &#x27;Product added&#x27; @res</span><br></pre></td></tr></table></figure><p>把结果放入一个变量内，解决这个问题。如下图所示：<br><img data-src="/../../images/20190808170652347.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在使用hexo和GitHub搭建个人博客时遇到的问题及解决方法</title>
      <link href="/2019/01/04/190103/"/>
      <url>/2019/01/04/190103/</url>
      
        <content type="html"><![CDATA[<h1 id="在使用hexo和GitHub搭建个人博客时遇到的问题及解决方法"><a href="#在使用hexo和GitHub搭建个人博客时遇到的问题及解决方法" class="headerlink" title="在使用hexo和GitHub搭建个人博客时遇到的问题及解决方法"></a>在使用hexo和GitHub搭建个人博客时遇到的问题及解决方法</h1><h2 id="1-hexo-init时报错"><a href="#1-hexo-init时报错" class="headerlink" title="1. hexo init时报错"></a>1. hexo init时报错</h2><blockquote><p><font color="red"><strong>Error</strong></font> local hexo not found in D:\hexo<br><font color="red"><strong>Error</strong></font> Try running “npm install hexo –save”</p></blockquote><p>第一次遇到这个问题，我试着按照提示在git bush里键入“npm install hexo -save”，但依旧报错,无果<br>接着按照网上的资料，尝试着键入 “cnpm install hexo -save”，这次虽然没有报错，但是..毫无反应</p><p>最后，用了最极端的方法…delete 删除了hexo文件夹里的所有文件，之后重新输入“hexo init”  然后显示正常<br><img data-src="/../../images/201901.png" alt="在这里插入图片描述"></p><h2 id="2-hexo运行后local-host4000无法正常访问"><a href="#2-hexo运行后local-host4000无法正常访问" class="headerlink" title="2.  hexo运行后local host4000无法正常访问"></a>2.  hexo运行后local host4000无法正常访问</h2><blockquote><p>$ hexo s<br>INFO    Start processing<br>INFO    Hexo is running at <a href="http://localhost:4000/">http://localhost:4000/</a>. Press ctrl+C to stop</p></blockquote><p>但是 访问locaolhost:4000无响应</p><p>出现这种情况是因为4000端口被占用，此时可以用“hexo s -p 5000”换一个端口访问，之后访问localhost：5000即可</p><p>每次都必须这样进行设置无疑是很麻烦的<br>所以我们可以在站点配置文件中修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sever:</span><br><span class="line">port:5000</span><br><span class="line">compress:True</span><br><span class="line">header：True</span><br></pre></td></tr></table></figure><p>在浏览器里访问<a href="http://localhost:5000就可以看到本地的hexo了">http://localhost:5000就可以看到本地的hexo了</a><br><img data-src="/../../images/201902.png" alt="在这里插入图片描述"></p><h2 id="3-将hexo上传到GitHub"><a href="#3-将hexo上传到GitHub" class="headerlink" title="3. 将hexo上传到GitHub"></a>3. 将hexo上传到GitHub</h2><p>在安装部署到github插件依赖时，修改_config.yml文件时，有一个巨大的坑 (〃´皿`)q<br><img data-src="/../../images/201903.png" alt="在这里插入图片描述"><br>type:后面是有<font color="red"><strong>空格</strong></font>的。。。<br>不论是站点配置文件还是主题配置文件，都要加空格，否则hexo g时会报错。</p><h2 id="4-新建categories和tags页面，但上传博客后内容为空白"><a href="#4-新建categories和tags页面，但上传博客后内容为空白" class="headerlink" title="4. 新建categories和tags页面，但上传博客后内容为空白"></a>4. 新建categories和tags页面，但上传博客后内容为空白</h2><p>在站点source文件夹中修改categories目录的index.md为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2022-01-09 21:07:27</span><br><span class="line">type: categories</span><br><span class="line">layout: categories</span><br></pre></td></tr></table></figure><p>修改tags目录的index.md为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2022-01-09 20:54:40</span><br><span class="line">type: tags</span><br><span class="line">layout: tags</span><br></pre></td></tr></table></figure><p>不加layout属性的话，点进categories和tags就无法正常显示。</p><h2 id="5-新建post模板"><a href="#5-新建post模板" class="headerlink" title="5. 新建post模板"></a>5. 新建post模板</h2><p>模板可以在scaffolds\post.md中修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">copyright: true</span><br><span class="line">top:</span><br><span class="line">description:</span><br></pre></td></tr></table></figure><h2 id="6-next主题的美化"><a href="#6-next主题的美化" class="headerlink" title="6. next主题的美化"></a>6. next主题的美化</h2><p> 可以参考<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">这篇博文</a>。要注意分清站点配置文件和主题配置文件。</p><hr><p>ps：hexo的文档中写timeZone的设置，默认会获取你电脑自身所在时区，但我的会莫名其妙出现阿拉伯文，所以还是设置下UTC吧~<br>pps：站点配置language可以写成zh-CN/zh-Hans，next主题文档中说只支持zh-Hans，但配成zh-CN也可以正常使用。</p><hr><p><strong>以上就是我在搭建个人博客的过程中遇到的问题及解决方法。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
